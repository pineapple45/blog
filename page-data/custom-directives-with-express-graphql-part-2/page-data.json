{"componentChunkName":"component---src-templates-single-post-js","path":"/custom-directives-with-express-graphql-part-2","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Custom directives with express-graphql [Part-2]\",\n  \"slug\": \"custom-directives-with-express-graphql-part-2\",\n  \"date\": \"29-06-2021\",\n  \"featureImage\": \"feature.jpg\",\n  \"excerpt\": \"Adding graphql schema and resolvers.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", {\n    \"id\": \"defining-graphql-schema\"\n  }, \"Defining graphql schema\"), mdx(\"p\", null, \"We defined simple structure for our photos app in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/custom-directives-with-express-graphql-part-1\"\n  }, \"part-1\"), \" of this blog.\"), mdx(\"p\", null, \"\\uD83D\\uDCCD Final code: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/main\"\n  }, \"Link\")), mdx(\"p\", null, \"\\uD83C\\uDF10 Live preview: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://pineapple45.github.io/custom-directives-with-express-graphql/\"\n  }, \"Link\")), mdx(\"p\", null, \"In this post we will implement the graphql schema and the corrosponding resolvers. So without wasting any time let's start.\\nAccording to the folder structure we defined in part-1 , the directory structure in the graphql folder will look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"|-src\\n|--graphql\\n|---resolvers\\n|----comments\\n|-----comments.ts\\n|-----index.ts\\n|----likes\\n|-----likes.ts\\n|-----index.ts\\n|----posts\\n|-----posts.ts\\n|-----index.ts\\n|----users\\n|-----users.ts\\n|-----index.ts\\n|----index.ts\\n|----utils.ts\\n|---schemas\\n|----index.ts\\n\")), mdx(\"p\", null, \"The graphql schema for the app will look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* src/graphql/schema/index.ts */\\nimport { buildSchema } from \\\"graphql\\\"\\n\\nconst schema = buildSchema(`\\n\\ninput PostInput {\\n    image: String\\n    title: String!\\n    description: String\\n    creatorId: ID!\\n}\\n\\ntype Post {\\n    _id: ID!\\n    image: String\\n    title: String!\\n    description: String\\n    creator: User!\\n    commentList: [Comment!]\\n    likeList: [Like!]\\n}\\n\\ninput CommentInput {\\n    text: String!\\n    postId: ID!\\n    creatorId: ID!\\n}\\n\\ntype Comment {\\n    _id: ID!\\n    text: String!\\n    post: Post!\\n    creator: User!\\n}\\n\\ninput LikeInput {\\n    postId: ID!\\n    creatorId: ID!\\n}\\n\\ntype Like {\\n    _id: ID!\\n    post: Post!\\n    creator: User!\\n}\\n\\nenum Role {\\n    AUTH_USER\\n    ADMIN\\n    MODERATOR\\n}\\n\\ninput UserInput {\\n    username: String!\\n    email: String!\\n    password: String!\\n}\\n\\ntype User {\\n    _id: ID!\\n    username: String! \\n    email: String!\\n    password: String\\n    role: Role!\\n    postList: [Post!]\\n    commentList: [Comment!]\\n    likeList: [Like!]\\n}\\n\\ntype AuthData {\\n    userId: ID!\\n    token: String!\\n    tokenExpiration: Int!\\n}\\n\\ntype RootQuery {\\n  listUsers: [User!] \\n  getUserById(_id: ID!): User!\\n  listPosts: [Post!]\\n  getPostById(_id: ID!): Post!\\n  listComments: [Comment!]\\n  getCommentById(_id: ID!): Comment!\\n  listLikes: [Like!]\\n  getLikeById(_id: ID!): Like!\\n  login(usernameOrEmail: String!, password: String!): AuthData!\\n}\\n\\ntype RootMutation {\\n  createUser(user: UserInput): User\\n  deleteUser(_id: ID!): String \\n  createPost(post: PostInput): Post \\n  deletePost(_id: ID!): String \\n  createComment(comment: CommentInput): Comment\\n  deleteComment(_id: ID!): String \\n  createLike(like: LikeInput): Like\\n  deleteLike(_id: ID!): String\\n  assignRole(role: String! , assignedBy: ID!, assignedUser: ID!): User \\n}\\n\\nschema {\\n  query: RootQuery\\n  mutation: RootMutation\\n}\\n`)\\n\\nexport default schema\\n\")), mdx(\"p\", null, \"Obviously the queries and mutations\\nthat I have implemented are what I thought are enough for this blog post. You can always update the\\nfeatures or even add new ones. There is so much scope for scaling in projects like these.\\nAlso the schema is getting a bit too long. So later on in this post or in the third part we will split it into seperate files (schema splitting).\"), mdx(\"p\", null, \"\\uD83D\\uDC49 I might make a few changes to this schema (specifically in the user schema) when I will integrate the server with frontend. But the overall there won't be any change in the overall logic. All of those changes will be reflected in the final code repository. In case of any problem , make sure to check with the final code.\"), mdx(\"p\", null, \"\\uD83D\\uDCCC The code till now can be found here: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/graphql-schema-formation-part-2\"\n  }, \"Link\")), mdx(\"h3\", {\n    \"id\": \"implementing-resolvers\"\n  }, \"Implementing resolvers\"), mdx(\"p\", null, \"\\uD83D\\uDC49 Please note that while implementing resolvers, we will have quite a few\\nfunctions and also some reusable ones. I have created utils files (as shown above in directory structure), that will contain all the reusable functions that will be shared among different resolvers. This is a very usefull and will make our code super reusable !!\\uD83D\\uDD25\"), mdx(\"p\", null, \"It is important to visualize what our resolvers will look like and how they will be structured.\"), mdx(\"p\", null, \"First we will start by adding all resolvers related to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"users\"), \". These will be as follows:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"createUser\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"login\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"listUsers\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"getUserById\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"assignRole\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"deleteUser\")), mdx(\"p\", null, \"Resolvers for \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"posts\"), \" , \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"comments\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"likes\"), \" will be very much similar structure wise. Ofcourse , their functionality will differ. We will handle these in a bit. For now let's start with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"createUser\"), \" & \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"login\"), \" resolvers which will provide registeration and login functionality!\"), mdx(\"h3\", {\n    \"id\": \"creating-the-utilities-file-\"\n  }, \"Creating the utilities file \\uD83D\\uDE80\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { UserType } from \\\"./users\\\"\\n\\nexport const transformUser = (user: UserType) => {\\n  if (!user)\\n    return {\\n      _id: \\\"deleted_user\\\",\\n      email: \\\"deleted_user\\\",\\n      username: \\\"deleted_user\\\",\\n      role: \\\"deleted_user\\\",\\n      password: null,\\n      postList: [], // return empty array as user has been deleted!\\n      commentList: [], // return empty array as user has been deleted!\\n      likeList: [], // return empty array as user has been deleted!\\n      /* functionality can be increased so as all user's comments, likes or posts(for admins)\\n       could be deleted before the user itself is deleted from database  */\\n    }\\n  return {\\n    _id: user._id,\\n    username: user.username,\\n    email: user.email,\\n    role: user.role,\\n    password: null,\\n    postList: [], // return empty array for now. we will add posts functionality in a bit\\n    commentList: [], // return empty array for now. we will add comments functionality in a bit\\n    likeList: [], // return empty array for now. we will add likes functionality in a bit\\n  }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"what-is-the-use-of-transform-functions-in-utils-file\"\n  }, \"What is the use of transform functions in utils file?\"), mdx(\"p\", null, \"After our resolvers are done with their operation , the final data returned by them is passed to transform functions which inturn return the data in a formatted way which\\ncan be returned by the resolver and which is expected by the schema( or as I should say : \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"specified in our schema\"), \"). We have a couple of transform functions such as transformUser , transformPost , transformLike and transformComment.\"), mdx(\"h3\", {\n    \"id\": \"creating-createuser--login-resolver\"\n  }, \"Creating createUser & login resolver\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import User, { Role } from \\\"../../../models/User\\\"\\nimport { transformUser } from \\\"../utils\\\"\\nimport bcrypt from \\\"bcrypt\\\"\\nimport jwt from \\\"jsonwebtoken\\\"\\n\\ninterface UserArgsType {\\n  user: UserType\\n}\\n\\nexport interface UserType {\\n  _id?: string\\n  username: string\\n  email: string\\n  password: string\\n  role: Role\\n}\\n\\ninterface UserLoginArgs {\\n  usernameOrEmail: string\\n  password: string\\n}\\n\\nexport const createUser = async (args: UserArgsType) => {\\n  const userInDb = await User.findOne({\\n    email: args.user.email,\\n    username: args.user.username,\\n  })\\n\\n  if (userInDb) {\\n    throw new Error(\\n      \\\"user with same username or email already exists in database\\\"\\n    )\\n  }\\n\\n  // encrypt password before saving to database\\n  const hashedPassword = await bcrypt.hash(args.user.password, 12)\\n\\n  const user = new User({\\n    username: args.user.username,\\n    email: args.user.email,\\n    password: hashedPassword,\\n  })\\n\\n  try {\\n    const result = await user.save()\\n    return transformUser(result)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\\nexport const login = async (args: UserLoginArgs) => {\\n  const login = checkIfValIsUsernameOrEmail(args.usernameOrEmail)\\n\\n  if (login.type === \\\"email\\\") {\\n    const emailCheck = await User.findOne({\\n      email: login.email,\\n    })\\n\\n    if (!emailCheck) {\\n      throw new Error(`No account found with email ${login.email}`)\\n    }\\n\\n    console.log(\\\"emailCheck\\\", emailCheck)\\n\\n    const data = passwordCheck(args, emailCheck)\\n    return data\\n  } else {\\n    console.log(login.username)\\n    const usernameCheck = await User.findOne({\\n      username: login.username,\\n    })\\n\\n    console.log(usernameCheck)\\n\\n    if (!usernameCheck) {\\n      throw new Error(`No account found with username ${login.username}`)\\n    }\\n\\n    const data = passwordCheck(args, usernameCheck)\\n    return data\\n  }\\n}\\n\\n// compare password entered by user to the one in the database\\nconst passwordCheck = async (args: UserLoginArgs, user: UserType) => {\\n  const isEqual = await bcrypt.compare(args.password, user.password)\\n  if (!isEqual) {\\n    throw new Error(\\\"Password is incorrect!\\\")\\n  }\\n  const token = jwt.sign(\\n    { userId: user._id, email: user.email, role: user.role },\\n    process.env.JWT_SECRET_KEY as string,\\n    {\\n      expiresIn: \\\"1h\\\",\\n    }\\n  )\\n  return { userId: user._id, token: token, tokenExpiration: 1 }\\n}\\n\\n// checkIfValIsUsernameOrEmail function checks weather input value entered by user during the\\n// time of login is either username or email. User can login with either one of the 2!\\nconst checkIfValIsUsernameOrEmail = (usernameOrEmail: string) => {\\n  // Check if email\\n  if (/\\\\@/.test(usernameOrEmail)) {\\n    //its email address\\n    // your code goes here\\n    return {\\n      type: \\\"email\\\",\\n      email: usernameOrEmail,\\n    }\\n  } else {\\n    //its username\\n    // your code goes here\\n    return {\\n      type: \\\"username\\\",\\n      username: usernameOrEmail,\\n    }\\n  }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"adding-the-root-resolver\"\n  }, \"Adding the root resolver\"), mdx(\"p\", null, \"We create an index.ts file under our resolvers root directory as shown before and the following code in it:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import * as usersResolver from \\\"./users\\\"\\n\\nconst rootResolver: any = {\\n  ...usersResolver,\\n}\\n\\nexport default rootResolver\\n\")), mdx(\"h3\", {\n    \"id\": \"updating-the-root-indexts-fileentry-point\"\n  }, \"Updating the root index.ts file(entry point)\"), mdx(\"p\", null, \"Now we add the graphql code to our index.ts file at the entry point that will basically join our resolvers to the schema that we defined. This way the arguments defined in our schema will enter into our resolvers! We will use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.npmjs.com/package/express-graphql\"\n  }, \"express-graphql\"), \" for this.\\nThe index.ts file till now looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import * as dotenv from \\\"dotenv\\\"\\ndotenv.config()\\nimport express, { Express } from \\\"express\\\"\\nimport mongoose from \\\"mongoose\\\"\\nimport { graphqlHTTP } from \\\"express-graphql\\\"\\nconst app: Express = express()\\nimport schema from \\\"./graphql/schemas\\\"\\nimport rootResolver from \\\"./graphql/resolvers\\\"\\n\\nconst PORT =\\n  process.env.NODE_ENV === \\\"production\\\"\\n    ? process.env.PORT\\n    : process.env.PORT_DEV\\n\\nconst MONGO_URI = process.env.MONGO_URI as string\\n\\napp.use(\\n  \\\"/graphql\\\",\\n  graphqlHTTP({\\n    schema: schema,\\n    rootValue: rootResolver,\\n    graphiql: true,\\n  })\\n)\\n\\nmongoose\\n  .connect(MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true })\\n  .then(() => {\\n    console.log(\\\"connected to mongodb...\\\")\\n    app.listen(PORT, () => {\\n      console.log(`server started on port ${PORT}`)\\n    })\\n  })\\n  .catch(err => {\\n    console.log(err)\\n  })\\n\")), mdx(\"p\", null, \"\\uD83D\\uDCCC The code till now can be found here: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/graphql-creatUser-login-resolver-part-2\"\n  }, \"Link\")), mdx(\"p\", null, \"Start the project and go to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://localhost:4000/graphql\"\n  }, \"http://localhost:4000/graphql\"), \". This is the playground where we will test our queries\\nand mutations. Later I will add a proper frontend using react-js. Let's test also with the queries and mutations that I have already written:\"), mdx(Video, {\n    videoSrcURL: \"https://www.youtube.com/embed/MGOpckT-1yI\",\n    videoTitle: \"https://www.youtube.com/embed/MGOpckT-1yI\",\n    mdxType: \"Video\"\n  }), mdx(\"p\", null, \"After running the createUser mutation above we have a user in our mongodb database as below:\"), mdx(\"p\", null, mdx(\"undefined\", {\n    parentName: \"p\"\n  }, \"\\n      \", mdx(\"div\", {\n    \"className\": \"gria-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"overflow\": \"hidden\"\n    }\n  }, \"\\n      \\n        \\n          \", mdx(\"div\", {\n    parentName: \"div\",\n    \"className\": \"gria-image-padding\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"paddingBottom\": \"25.5%\"\n    }\n  }), \"\\n        \\n        \\n      \\n      \", mdx(\"div\", {\n    parentName: \"div\",\n    \"className\": \"gria-image-placeholder\",\n    \"style\": {\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\",\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"background\": \"#fff url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAp0lEQVQY052QwWrDMBAF8/9/2IQeenFw3CaWZa9Wa3UnSI4hgZJDHwxvEWJY6QDw605OAvGGzyPEKx6+N8Zha4m4g7v/SU3tQx3MjHPX8XMZ6IcbMUyQ5cECplCMd9mlTaiqHE8nvroLH13gs5/ogzLn0ohakNrJGouuzGqNSYyU19cNSymMYWQRIVlhqZfTRp2rRPJKlE2ynzdxMtTKq/D5H/6b/cl3QpCIEFli6UgAAAAASUVORK5CYII=) center / cover no-repeat\"\n    }\n  }), \"\\n    \\n    \", mdx(\"picture\", {\n    parentName: \"div\"\n  }, \"\\n      \", mdx(\"source\", {\n    parentName: \"picture\",\n    \"srcSet\": [\"/static/824df77c032ec4be3508f69e57476933/772e8/P2UUlwOVw.png 200w\", \"/static/824df77c032ec4be3508f69e57476933/e17e5/P2UUlwOVw.png 400w\", \"/static/824df77c032ec4be3508f69e57476933/fdaf8/P2UUlwOVw.png 674w\"]\n  }), \"\\n      \", mdx(\"img\", {\n    parentName: \"picture\",\n    \"className\": \"gria-image\",\n    \"src\": \"/static/824df77c032ec4be3508f69e57476933/fdaf8/P2UUlwOVw.png\",\n    \"srcSet\": [\"/static/824df77c032ec4be3508f69e57476933/772e8/P2UUlwOVw.png 200w\", \"/static/824df77c032ec4be3508f69e57476933/e17e5/P2UUlwOVw.png 400w\", \"/static/824df77c032ec4be3508f69e57476933/fdaf8/P2UUlwOVw.png 674w\"],\n    \"title\": \"1.png\",\n    \"alt\": \"1.png\",\n    \"loading\": \"lazy\",\n    \"style\": {\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\",\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"objectFit\": \"cover\",\n      \"objectPosition\": \"center center\"\n    }\n  }), \"\\n    \"), \"\\n  \\n      \"), \"\\n    \")), mdx(\"h3\", {\n    \"id\": \"adding-remaining-resolvers-related-to-users\"\n  }, \"Adding remaining resolvers related to users\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"listUsers \"), \" resolver is responsible for listing all registered users in our database.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* listUsers resolver */\\nexport const listUsers = async () => {\\n  try {\\n    const users = await User.find()\\n    return users.map((user: UserType) => {\\n      return transformUser(user)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"getUserById \"), \" resolver is responsible for listing any specific user from database with the help of an user-id.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* getUserById resolver*/\\nexport const getUserById = async (args: { _id: string }) => {\\n  try {\\n    const user = await User.findById(args._id)\\n    return transformUser(user)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"deleteUser \"), \" resolver is responsible for deleting a user.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* deleteUser resolver */\\nexport const deleteUser = async (_id: string) => {\\n  try {\\n    await User.findByIdAndDelete(_id)\\n    return `user account removed successfully`\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"assignRole\"), \" resolver is responsible for assigning a specific role to any registered user. By default \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"AUTH_USER\"), \" is the default role. Also note that only Admin can update a user's role as per our requirements.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* assignRole resolver */\\nexport const assignRole = async (args: {\\n  role: Role\\n  assignedBy: string\\n  assignedUser: string\\n}) => {\\n  try {\\n    const assigny = await User.findById(args.assignedBy)\\n    if (!assigny) {\\n      throw new Error(\\\"The user who is assigning role is not present in db\\\")\\n    }\\n\\n    const userToBeAssigned = await User.findById(args.assignedUser)\\n    if (userToBeAssigned._doc.role === \\\"ADMIN\\\")\\n      throw new Error(`User is already assigned ${args.role} role`)\\n\\n    const updatedUser = await User.updateOne(\\n      { _id: args.assignedUser },\\n      { $set: { role: args.role } }\\n    )\\n\\n    const result = await User.findById(args.assignedUser)\\n    return transformUser(result)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"p\", null, \"First let's test listUsers and getUserById:\"), mdx(Video, {\n    videoSrcURL: \"https://www.youtube.com/embed/sZG5MwmWHng\",\n    videoTitle: \"https://www.youtube.com/embed/sZG5MwmWHng\",\n    mdxType: \"Video\"\n  }), mdx(\"p\", null, \"\\uD83D\\uDC49 Note that for now there is no authorisation. Anyone can authorize any role to anyone. Also in case of posts and comments, anyone can create posts or add comments. We will take care of authorization in part-3\"), mdx(\"p\", null, \"Now Let's assign a new role to a user. I create a new user with the name of jane doe. We will assign a role of MODERATOR to jane doe. For now let's assume John doe was already an ADMIN. Later we will add authorization logic to check weather a person\\nassigning a role to someone himself is ADMIN or not!\"), mdx(Video, {\n    videoSrcURL: \"https://www.youtube.com/embed/abewZfGDk3w\",\n    videoTitle: \"https://www.youtube.com/embed/abewZfGDk3w\",\n    mdxType: \"Video\"\n  }), mdx(\"p\", null, \"Now finally let's delete a user. Let's delete Jane Doe:\"), mdx(Video, {\n    videoSrcURL: \"https://www.youtube.com/embed/wZCT2SW9_SA\",\n    videoTitle: \"https://www.youtube.com/embed/wZCT2SW9_SA\",\n    mdxType: \"Video\"\n  }), mdx(\"p\", null, \"Seems like, all of our user resolvers works till now!\\uD83D\\uDE03\"), mdx(\"p\", null, \"\\uD83D\\uDCCC The code till now can be found here: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/all-resolvers-related-to-users-part-2\"\n  }, \"Link\")), mdx(\"h3\", {\n    \"id\": \"adding-resolvers-related-to-posts\"\n  }, \"Adding resolvers related to posts\"), mdx(\"p\", null, \"Let's first update the utils file where we add a few utility functions that will be used by all resolvers related to posts.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* utils */\\n\\nimport User from \\\"../../models/User\\\"\\nimport Post from \\\"../../models/Post\\\"\\nimport { UserType } from \\\"./users\\\"\\nimport { PostType } from \\\"./posts\\\"\\n\\nexport const transformUser = (user: UserType) => {\\n  if (!user)\\n    return {\\n      _id: \\\"deleted_user\\\",\\n      email: \\\"deleted_user\\\",\\n      username: \\\"deleted_user\\\",\\n      role: \\\"deleted_user\\\",\\n      password: null,\\n      postList: [], // return empty array as user has been deleted!\\n      commentList: [], // return empty array as user has been deleted!\\n      likeList: [], // return empty array as user has been deleted!\\n      /* functionality can be increased so as all user's comments, likes or posts(for admins)\\n       could be deleted before the user itself is deleted from database  */\\n    }\\n  return {\\n    _id: user._id,\\n    username: user.username,\\n    email: user.email,\\n    role: user.role,\\n    password: null,\\n    postList: postsByCreatorId.bind(this, user._id!),\\n    commentList: [], // return empty array for now. we will add comments functionality in a bit\\n    likeList: [], // return empty array for now. we will add likes functionality in a bit\\n  }\\n}\\n\\nexport const transformPost = (post: PostType) => {\\n  return {\\n    _id: post._id,\\n    image: post.image,\\n    title: post.title,\\n    description: post.description,\\n    creator: singleUser.bind(this, post.creatorId),\\n    commentList: [], // return empty array for now. we will add comments functionality in a bit\\n    likeList: [], // return empty array for now. we will add likes functionality in a bit\\n  }\\n}\\n\\n/* singleUser utility func to retreive single user by Id*/\\nexport const singleUser = async (userId: string) => {\\n  try {\\n    const user = await User.findById(userId)\\n    return transformUser(user)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\\n/* postsByCreatorId utility func to list all posts created by a single creator(user) */\\nexport const postsByCreatorId = async (creatorId: string) => {\\n  try {\\n    const posts = await Post.find({ creatorId: creatorId })\\n    return posts.map((post: PostType) => {\\n      return transformPost(post)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"p\", null, \"Now we add all post resolvers:\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"createPost \"), \"resolver is responsible for creating a new post.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* createPost resolver */\\nexport const createPost = async (args: PostArgsType) => {\\n  const post = new Post({\\n    image: args.post.image,\\n    title: args.post.title,\\n    description: args.post.description,\\n    creatorId: args.post.creatorId,\\n  })\\n\\n  try {\\n    const result = await post.save()\\n    return transformPost(result)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"deletePost\"), \" resolver is responsible for deleting a post.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* deletePost resolver */\\nexport const deletePost = async (_id: string) => {\\n  try {\\n    await Post.findByIdAndDelete(_id)\\n    return `post removed successfully`\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"getPostById\"), \" is responsible for retreiving a single post.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* getPostById resolver */\\nexport const getPostById = async (args: { _id: string }) => {\\n  try {\\n    const post = await Post.findById(args._id)\\n    return transformPost(post)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"listPosts \"), \"resolver is responsible for listing all posts\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* listPosts resolver*/\\nexport const listPosts = async () => {\\n  try {\\n    const posts = await Post.find()\\n    return posts.map((post: PostType) => {\\n      return transformPost(post)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"updating-the-root-resolver\"\n  }, \"Updating the root resolver\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import * as usersResolver from \\\"./users\\\"\\nimport * as postsResolver from \\\"./posts\\\"\\n\\nconst rootResolver: any = {\\n  ...usersResolver,\\n  ...postsResolver,\\n}\\n\\nexport default rootResolver\\n\")), mdx(\"p\", null, \"Now we test the post resolvers. Let's say John Doe was creating, listing and deleting a few posts. Again assuming he is an ADMIN for now, he can do such operations.\"), mdx(Video, {\n    videoSrcURL: \"https://www.youtube.com/embed/c_y7KCV-m6g\",\n    videoTitle: \"https://www.youtube.com/embed/c_y7KCV-m6g\",\n    mdxType: \"Video\"\n  }), mdx(\"p\", null, \"\\uD83D\\uDC49 Do notice that now we can also fetch the details of the user who created a post since we have already created all resolvers related to users. Similary when we create resolvers of comments and likes, we will also be able to fetch all comments and likes associated with each of the posts. Similar relationship will also be there for comments and likes. For eg. we will be able to fetch each like and the corrosponding user who created the like as well as the post on which like was added. You can imagine such nesting will keep on happening. Over here the power of graphql begins to shine!\"), mdx(\"p\", null, \"We have successfully added posts resolver. Now since you have the idea how resolvers are being added, I would now add the comments and likes resolvers quickly. The structure and logic is pretty much similar to that of posts. You can try that on your own. Again everything is defined already in graphql schema.\\nYou can refer to it whenever you are stuck and design resolvers according to that.\"), mdx(\"p\", null, \"\\uD83D\\uDCCC The code till now can be found here: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/posts-all-resolvers-part-2\"\n  }, \"Link\")), mdx(\"h3\", {\n    \"id\": \"adding-comments-resolvers\"\n  }, \"Adding comments resolvers\"), mdx(\"p\", null, \"First updating the utils file, we will need a couple of new utiltiy functions:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const transformUser = (user: UserType) => {\\n  if (!user)\\n    return {\\n      _id: \\\"deleted_user\\\",\\n      email: \\\"deleted_user\\\",\\n      username: \\\"deleted_user\\\",\\n      role: \\\"deleted_user\\\",\\n      password: null,\\n      postList: [], // return empty array as user has been deleted!\\n      commentList: [], // return empty array as user has been deleted!\\n      likeList: [], // return empty array as user has been deleted!\\n      /* functionality can be increased so as all user's comments, likes or posts(for admins)\\n       could be deleted before the user itself is deleted from database  */\\n    }\\n  return {\\n    _id: user._id,\\n    username: user.username,\\n    email: user.email,\\n    role: user.role,\\n    password: null,\\n    postList: postsByCreatorId.bind(this, user._id!),\\n    commentList: commentsByCreatorId.bind(this, user._id!),\\n    likeList: [], // return empty array for now. we will add likes functionality in a bit\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const transformPost = (post: PostType) => {\\n  return {\\n    _id: post._id,\\n    image: post.image,\\n    title: post.title,\\n    description: post.description,\\n    creator: singleUser.bind(this, post.creatorId),\\n    commentList: commentsByPostId.bind(this, post._id!),\\n    likeList: [], // return empty array for now. we will add likes functionality in a bit\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const transformComment = (comment: CommentType) => {\\n  return {\\n    _id: comment._id,\\n    text: comment.text,\\n    post: singlePost.bind(this, comment.postId),\\n    creator: singleUser.bind(this, comment.creatorId),\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* singlePost utility func to get post using post-id*/\\nexport const singlePost = async (postId: string) => {\\n  try {\\n    const post = await Post.findById(postId)\\n    return transformPost(post)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* commentsByPostId utility func to get all comments on a single post */\\nexport const commentsByPostId = async (postId: string) => {\\n  try {\\n    const comments = await Comment.find({ postId: postId })\\n    return comments.map((comment: CommentType) => {\\n      return transformComment(comment)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* commentsByCreatorId utility func to get all comments of a single user */\\nexport const commentsByCreatorId = async (creatorId: string) => {\\n  try {\\n    const comments = await Comment.find({ creatorId: creatorId })\\n    return comments.map((comment: CommentType) => {\\n      return transformComment(comment)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"p\", null, \"Now all the resolvers related to comments will be like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import Comment from \\\"../../../models/Comment\\\"\\nimport { transformComment } from \\\"../utils\\\"\\n\\nexport interface CommentType {\\n  _id: string\\n  text: string\\n  postId: string\\n  creatorId: string\\n}\\n\\ninterface CommentArgsType {\\n  comment: CommentType\\n}\\n\\n/* listComments resolver to list all comments */\\nexport const listComments = async () => {\\n  try {\\n    const comments = await Comment.find()\\n    return comments.map((comment: CommentType) => {\\n      return transformComment(comment)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\\n/* getCommentById resolver to get single comment by it's id */\\nexport const getCommentById = async (args: { _id: string }) => {\\n  try {\\n    const comment = await Comment.findById(args._id)\\n    return transformComment(comment)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\\n/* createComment  resolver to create a comment */\\nexport const createComment = async (args: CommentArgsType) => {\\n  const comment = new Comment({\\n    text: args.comment.text,\\n    postId: args.comment.postId,\\n    creatorId: args.comment.creatorId,\\n  })\\n\\n  try {\\n    const result = await comment.save()\\n    return transformComment(result)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\\n/* deleteComment  resolver to delete a single comment using it's id */\\nexport const deleteComment = async (_id: string) => {\\n  try {\\n    await Comment.findByIdAndDelete(_id)\\n    return `comment removed successfully`\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"updating-the-root-resolver-file-again\"\n  }, \"Updating the root resolver file again:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import * as usersResolver from \\\"./users\\\"\\nimport * as postsResolver from \\\"./posts\\\"\\nimport * as commentsResolver from \\\"./comments\\\"\\n\\nconst rootResolver: any = {\\n  ...usersResolver,\\n  ...postsResolver,\\n  ...commentsResolver,\\n}\\n\\nexport default rootResolver\\n\")), mdx(\"p\", null, \"Now let's test the comments resolver. For this I have already created 2 new users and 2 new posts. Then I will add\\n1 comment to each of the posts.\"), mdx(Video, {\n    videoSrcURL: \"https://www.youtube.com/embed/6vYQklS8b3A\",\n    videoTitle: \"https://www.youtube.com/embed/6vYQklS8b3A\",\n    mdxType: \"Video\"\n  }), mdx(\"p\", null, \"\\uD83D\\uDCCCThe code till now can be found here: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/all-comments-resolvers-part-2\"\n  }, \"Link\")), mdx(\"h3\", {\n    \"id\": \"adding-likes-resolvers\"\n  }, \"Adding likes resolvers\"), mdx(\"p\", null, \"First updating the utils file, we will need 2 new functions:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const transformPost = (post: PostType) => {\\n  return {\\n    _id: post._id,\\n    image: post.image,\\n    title: post.title,\\n    description: post.description,\\n    creator: singleUser.bind(this, post.creatorId),\\n    commentList: commentsByPostId.bind(this, post._id!),\\n    likeList: likesByPostId.bind(this, post._id!),\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const transformComment = (comment: CommentType) => {\\n  return {\\n    _id: comment._id,\\n    text: comment.text,\\n    post: singlePost.bind(this, comment.postId),\\n    creator: singleUser.bind(this, comment.creatorId),\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const transformLike = (like: LikeType) => {\\n  return {\\n    _id: like._id,\\n    post: singlePost.bind(this, like.postId),\\n    creator: singleUser.bind(this, like.creatorId),\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* likesByPostId utility func to list all likes related to any single post using post-id */\\nexport const likesByPostId = async (postId: string) => {\\n  try {\\n    const likes = await Like.find({ postId: postId })\\n    return likes.map((like: any) => {\\n      return transformLike(like)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* likesByCreatorId utility func to list all likes related to any single user using user-id */\\nexport const likesByCreatorId = async (creatorId: string) => {\\n  try {\\n    const likes = await Like.find({ creatorId: creatorId })\\n    return likes.map((like: LikeType) => {\\n      return transformLike(like)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"p\", null, \"Now all the resolvers related to likes will be like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import Like from \\\"../../../models/Like\\\"\\nimport { transformLike } from \\\"../utils\\\"\\n\\nexport interface LikeType {\\n  _id?: string\\n  postId: string\\n  creatorId: string\\n}\\n\\ninterface LikeArgsType {\\n  like: LikeType\\n}\\n\\n/* listLikes resolver to list all likes */\\nexport const listLikes = async () => {\\n  try {\\n    const likes = await Like.find()\\n    return likes.map((like: LikeType) => {\\n      return transformLike(like)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\\n/* getLikeById resolver to retreive a single like using a like-id */\\nexport const getLikeById = async (args: { _id: string }) => {\\n  try {\\n    const like = await Like.findById(args._id)\\n    return transformLike(like)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\\n/* createLike resolver for adding a like to the post */\\nexport const createLike = async (args: LikeArgsType) => {\\n  const like = new Like({\\n    postId: args.like.postId,\\n    creatorId: args.like.creatorId,\\n  })\\n\\n  try {\\n    const result = await like.save()\\n    return transformLike(result)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\\n/* deleteLike resolver for removing a like*/\\nexport const deleteLike = async (_id: string) => {\\n  try {\\n    await Like.findByIdAndDelete(_id)\\n    return `like removed successfully`\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"updating-the-root-resolver-file-again-1\"\n  }, \"Updating the root resolver file again:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import * as usersResolver from \\\"./users\\\"\\nimport * as postsResolver from \\\"./posts\\\"\\nimport * as commentsResolver from \\\"./comments\\\"\\nimport * as likesResolver from \\\"./likes\\\"\\n\\nconst rootResolver: any = {\\n  ...usersResolver,\\n  ...postsResolver,\\n  ...commentsResolver,\\n  ...likesResolver,\\n}\\n\\nexport default rootResolver\\n\")), mdx(\"p\", null, \"I won't be testing all likes resolver because the implementation is very much like comments. You can try this part on your own.\"), mdx(\"p\", null, \"\\uD83D\\uDCCC The code till now can be found here: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/all-likes-resolvers-part-2\"\n  }, \"Link\")), mdx(\"p\", null, \"If you have made it this far then congratulations.. we have completed the base of our complete! Now in next part we will implement custom directives and add the frontend!\"), mdx(\"p\", null, \"\\uD83D\\uDC49 Note: In the final code repository there is a client-redux folder which also consists of frontend with client graphql implementation using redux. Although , it is important to note that, functionalities such live as refetching of queries , implementaion of custom fetch and error policies is not implemented in this project.\"), mdx(\"p\", null, \"\\uD83D\\uDCCD Final code: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/main\"\n  }, \"Link\")), mdx(\"p\", null, \"\\uD83C\\uDF10 Live preview: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://pineapple45.github.io/custom-directives-with-express-graphql/\"\n  }, \"Link\")), mdx(\"p\", null, \"You can view Part 3 of the series here: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/custom-directives-with-express-graphql-part-3\"\n  }, \"part 3 ->\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#defining-graphql-schema","title":"Defining graphql schema"},{"url":"#implementing-resolvers","title":"Implementing resolvers"},{"url":"#creating-the-utilities-file-","title":"Creating the utilities file ðŸš€"},{"url":"#what-is-the-use-of-transform-functions-in-utils-file","title":"What is the use of transform functions in utils file?"},{"url":"#creating-createuser--login-resolver","title":"Creating createUser & login resolver"},{"url":"#adding-the-root-resolver","title":"Adding the root resolver"},{"url":"#updating-the-root-indexts-fileentry-point","title":"Updating the root index.ts file(entry point)"},{"url":"#adding-remaining-resolvers-related-to-users","title":"Adding remaining resolvers related to users"},{"url":"#adding-resolvers-related-to-posts","title":"Adding resolvers related to posts"},{"url":"#updating-the-root-resolver","title":"Updating the root resolver"},{"url":"#adding-comments-resolvers","title":"Adding comments resolvers"},{"url":"#updating-the-root-resolver-file-again","title":"Updating the root resolver file again:"},{"url":"#adding-likes-resolvers","title":"Adding likes resolvers"},{"url":"#updating-the-root-resolver-file-again-1","title":"Updating the root resolver file again:"}]},"headings":[{"depth":3,"value":"Defining graphql schema"},{"depth":3,"value":"Implementing resolvers"},{"depth":3,"value":"Creating the utilities file ðŸš€"},{"depth":3,"value":"What is the use of transform functions in utils file?"},{"depth":3,"value":"Creating createUser & login resolver"},{"depth":3,"value":"Adding the root resolver"},{"depth":3,"value":"Updating the root index.ts file(entry point)"},{"depth":3,"value":"Adding remaining resolvers related to users"},{"depth":3,"value":"Adding resolvers related to posts"},{"depth":3,"value":"Updating the root resolver"},{"depth":3,"value":"Adding comments resolvers"},{"depth":3,"value":"Updating the root resolver file again:"},{"depth":3,"value":"Adding likes resolvers"},{"depth":3,"value":"Updating the root resolver file again:"}],"frontmatter":{"date":"29-06-2021","excerpt":"Adding graphql schema and resolvers.","slug":"custom-directives-with-express-graphql-part-2","title":"Custom directives with express-graphql [Part-2]","featureImage":{"publicURL":"/static/1b289d874439805d34eead0c1756920b/feature.jpg","childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAEDBf/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAABy6yMRiD/xAAZEAACAwEAAAAAAAAAAAAAAAAAAgERICH/2gAIAQEAAQUCGSieY//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABgQAAIDAAAAAAAAAAAAAAAAAAABESAi/9oACAEBAAY/AhaTmv8A/8QAGhABAAEFAAAAAAAAAAAAAAAAEQABICFBUf/aAAgBAQABPyEnDBxqUIs//9oADAMBAAIAAwAAABDAD//EABYRAAMAAAAAAAAAAAAAAAAAAAEQYf/aAAgBAwEBPxAxf//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAQEAAQUAAAAAAAAAAAAAAAERACAxQXGR/9oACAEBAAE/ECi0O8MztsvDl2hnJo//2Q==","aspectRatio":1.5384615384615385,"src":"/static/1b289d874439805d34eead0c1756920b/14b42/feature.jpg","srcSet":"/static/1b289d874439805d34eead0c1756920b/f836f/feature.jpg 200w,\n/static/1b289d874439805d34eead0c1756920b/2244e/feature.jpg 400w,\n/static/1b289d874439805d34eead0c1756920b/14b42/feature.jpg 800w,\n/static/1b289d874439805d34eead0c1756920b/47498/feature.jpg 1200w,\n/static/1b289d874439805d34eead0c1756920b/0e329/feature.jpg 1600w,\n/static/1b289d874439805d34eead0c1756920b/ee1b0/feature.jpg 1721w","sizes":"(max-width: 800px) 100vw, 800px"}}}}}},"pageContext":{"id":"14d8a1d2-b55a-54fe-af66-6d898ed98ef5"}},"staticQueryHashes":["2933417362","3079204723"]}