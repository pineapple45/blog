{"componentChunkName":"component---src-templates-single-post-js","path":"/custom-directives-with-express-graphql-part-2","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Custom directives with express-graphql [Part-2]\",\n  \"slug\": \"custom-directives-with-express-graphql-part-2\",\n  \"date\": \"29-06-2021\",\n  \"featureImage\": \"feature.jpg\",\n  \"excerpt\": \"Adding graphql schema and resolvers.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", {\n    \"id\": \"defining-graphql-schema\"\n  }, \"Defining graphql schema\"), mdx(\"p\", null, \"We defined the overall structure in part-1 of this blog.\\nFinal code can be found here: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/schema-splitting-part-3\"\n  }, \"Link\")), mdx(\"p\", null, \"The directory structure in the graphql folder will look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"|-src\\n|--graphql\\n|---resolvers\\n|----comments\\n|-----comments.ts\\n|-----index.ts\\n|----likes\\n|-----likes.ts\\n|-----index.ts\\n|----posts\\n|-----posts.ts\\n|-----index.ts\\n|----users\\n|-----users.ts\\n|-----index.ts\\n|----index.ts\\n|----utils.ts\\n|---schemas\\n|----index.ts\\n\")), mdx(\"p\", null, \"The graphql schema for the app will look something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* src/graphql/schema/index.ts */\\nimport { buildSchema } from \\\"graphql\\\"\\n\\nconst schema = buildSchema(`\\n\\ninput PostInput {\\n    image: String\\n    title: String!\\n    description: String\\n    creatorId: ID!\\n}\\n\\ntype Post {\\n    _id: ID!\\n    image: String\\n    title: String!\\n    description: String\\n    creator: User!\\n    commentList: [Comment!]\\n    likeList: [Like!]\\n}\\n\\ninput CommentInput {\\n    text: String!\\n    postId: ID!\\n    creatorId: ID!\\n}\\n\\ntype Comment {\\n    _id: ID!\\n    text: String!\\n    post: Post!\\n    creator: User!\\n}\\n\\ninput LikeInput {\\n    postId: ID!\\n    creatorId: ID!\\n}\\n\\ntype Like {\\n    _id: ID!\\n    post: Post!\\n    creator: User!\\n}\\n\\nenum Role {\\n    AUTH_USER\\n    ADMIN\\n    MODERATOR\\n}\\n\\ninput UserInput {\\n    username: String!\\n    email: String!\\n    password: String!\\n}\\n\\ntype User {\\n    _id: ID!\\n    username: String! \\n    email: String!\\n    password: String\\n    role: Role!\\n    postList: [Post!]\\n    commentList: [Comment!]\\n    likeList: [Like!]\\n}\\n\\ntype AuthData {\\n    userId: ID!\\n    token: String!\\n    tokenExpiration: Int!\\n}\\n\\ntype RootQuery {\\n  listUsers: [User!] \\n  getUserById(_id: ID!): User!\\n  listPosts: [Post!]\\n  getPostById(_id: ID!): Post!\\n  listComments: [Comment!]\\n  getCommentById(_id: ID!): Comment!\\n  listLikes: [Like!]\\n  getLikeById(_id: ID!): Like!\\n  login(usernameOrEmail: String!, password: String!): AuthData!\\n}\\n\\ntype RootMutation {\\n  createUser(user: UserInput): User\\n  deleteUser(_id: ID!): String \\n  createPost(post: PostInput): Post \\n  deletePost(_id: ID!): String \\n  createComment(comment: CommentInput): Comment\\n  deleteComment(_id: ID!): String \\n  createLike(like: LikeInput): Like\\n  deleteLike(_id: ID!): String\\n  assignRole(role: String! , assignedBy: ID!, assignedUser: ID!): User \\n}\\n\\nschema {\\n  query: RootQuery\\n  mutation: RootMutation\\n}\\n`)\\n\\nexport default schema\\n\")), mdx(\"p\", null, \"Obviously the queries and mutations\\nthat I have implemented are what I thought are enough for this blog post. You can always update the\\nfeatures or even add new ones. There is so much scope for scaling in projects like these.\\nAlso the schema is getting a bit too long. So later on in this post or in the third part we will\\nsplit it into seperate files (schema splitting).\"), mdx(Checkpoint, {\n    checkpoint: \"The code till now can be found here\",\n    repoLink: \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/graphql-schema-formation-part-2\",\n    mdxType: \"Checkpoint\"\n  }), mdx(\"h3\", {\n    \"id\": \"implementing-resolvers\"\n  }, \"Implementing resolvers\"), mdx(Note, {\n    note: \"Please note that while implementing resolvers, we will have quite a few functions and also some reusable ones. I have created utils files (as shown above in directory structure), that will contain all the reusable functions that will be shared among different resolvers. This is a very usefull file and will make our code super reusable !!\\uD83D\\uDD25\",\n    mdxType: \"Note\"\n  }), mdx(\"p\", null, \"It is important to visualize what our resolvers will look like and how they will be structured.\"), mdx(\"p\", null, \"First we will start by adding all resolvers related to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"users\"), \". These will be as follows:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"createUser\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"login\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"listUsers\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"getUserById\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"assignRole\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"deleteUser\")), mdx(\"p\", null, \"Resolvers for \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"posts\"), \" , \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"comments\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"likes\"), \" will be very much similar structure wise. Ofcourse , their\\nfunctionality will differ. We will handle these in a bit. For now let's start with \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"createUser\"), \" & \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"login\"), \"\\nresolvers which will provide registeration and login functionality!\"), mdx(\"h3\", {\n    \"id\": \"creating-the-utilities-file-\"\n  }, \"Creating the utilities file \\uD83D\\uDE80\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { UserType } from \\\"./users\\\"\\n\\nexport const transformUser = (user: UserType) => {\\n  if (!user)\\n    return {\\n      _id: \\\"deleted_user\\\",\\n      email: \\\"deleted_user\\\",\\n      username: \\\"deleted_user\\\",\\n      role: \\\"deleted_user\\\",\\n      password: null,\\n      postList: [], // return empty array as user has been deleted!\\n      commentList: [], // return empty array as user has been deleted!\\n      likeList: [], // return empty array as user has been deleted!\\n      /* functionality can be increased so as all user's comments, likes or posts(for admins)\\n       could be deleted before the user itself is deleted from database  */\\n    }\\n  return {\\n    _id: user._id,\\n    username: user.username,\\n    email: user.email,\\n    role: user.role,\\n    password: null,\\n    postList: [], // return empty array for now. we will add posts functionality in a bit\\n    commentList: [], // return empty array for now. we will add comments functionality in a bit\\n    likeList: [], // return empty array for now. we will add likes functionality in a bit\\n  }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"creating-createuser--login-resolver\"\n  }, \"Creating createUser & login resolver\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import User, { Role } from \\\"../../../models/User\\\"\\nimport { transformUser } from \\\"../utils\\\"\\nimport bcrypt from \\\"bcrypt\\\"\\nimport jwt from \\\"jsonwebtoken\\\"\\n\\ninterface UserArgsType {\\n  user: UserType\\n}\\n\\nexport interface UserType {\\n  _id?: string\\n  username: string\\n  email: string\\n  password: string\\n  role: Role\\n}\\n\\ninterface UserLoginArgs {\\n  usernameOrEmail: string\\n  password: string\\n}\\n\\nexport const createUser = async (args: UserArgsType) => {\\n  const userInDb = await User.findOne({\\n    email: args.user.email,\\n    username: args.user.username,\\n  })\\n\\n  if (userInDb) {\\n    throw new Error(\\n      \\\"user with same username or email already exists in database\\\"\\n    )\\n  }\\n\\n  // encrypt password before savinf to database\\n  const hashedPassword = await bcrypt.hash(args.user.password, 12)\\n\\n  const user = new User({\\n    username: args.user.username,\\n    email: args.user.email,\\n    password: hashedPassword,\\n  })\\n\\n  try {\\n    const result = await user.save()\\n    return transformUser(result)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\\nexport const login = async (args: UserLoginArgs) => {\\n  const login = checkIfValIsUsernameOrEmail(args.usernameOrEmail)\\n\\n  if (login.type === \\\"email\\\") {\\n    const emailCheck = await User.findOne({\\n      email: login.email,\\n    })\\n\\n    if (!emailCheck) {\\n      throw new Error(`No account found with email ${login.email}`)\\n    }\\n\\n    console.log(\\\"emailCheck\\\", emailCheck)\\n\\n    const data = passwordCheck(args, emailCheck)\\n    return data\\n  } else {\\n    console.log(login.username)\\n    const usernameCheck = await User.findOne({\\n      username: login.username,\\n    })\\n\\n    console.log(usernameCheck)\\n\\n    if (!usernameCheck) {\\n      throw new Error(`No account found with username ${login.username}`)\\n    }\\n\\n    const data = passwordCheck(args, usernameCheck)\\n    return data\\n  }\\n}\\n\\n// compare password entered by user to the one in the database\\nconst passwordCheck = async (args: UserLoginArgs, user: UserType) => {\\n  const isEqual = await bcrypt.compare(args.password, user.password)\\n  if (!isEqual) {\\n    throw new Error(\\\"Password is incorrect!\\\")\\n  }\\n  const token = jwt.sign(\\n    { userId: user._id, email: user.email, role: user.role },\\n    process.env.JWT_SECRET_KEY as string,\\n    {\\n      expiresIn: \\\"1h\\\",\\n    }\\n  )\\n  return { userId: user._id, token: token, tokenExpiration: 1 }\\n}\\n\\n// checkIfValIsUsernameOrEmail function checks weather input value entered by user during the\\n// time of login is either username or email. User can login with either one of the 2!\\nconst checkIfValIsUsernameOrEmail = (usernameOrEmail: string) => {\\n  // Check if email\\n  if (/\\\\@/.test(usernameOrEmail)) {\\n    //its email address\\n    // your code goes here\\n    return {\\n      type: \\\"email\\\",\\n      email: usernameOrEmail,\\n    }\\n  } else {\\n    //its username\\n    // your code goes here\\n    return {\\n      type: \\\"username\\\",\\n      username: usernameOrEmail,\\n    }\\n  }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"adding-the-root-resolver\"\n  }, \"Adding the root resolver\"), mdx(\"p\", null, \"We create an index.ts file under our resolvers root directory as shown before and the following code in it\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import * as usersResolver from \\\"./users\\\"\\n\\nconst rootResolver: any = {\\n  ...usersResolver,\\n}\\n\\nexport default rootResolver\\n\")), mdx(\"h3\", {\n    \"id\": \"updating-the-root-indexts-fileentry-point\"\n  }, \"updating the root index.ts file(entry point)\"), mdx(\"p\", null, \"Now we add the graphql code to our index.ts file at the entry point that will basically join our\\nresolvers to the schema that we defined. This way the args will enter into our resolvers!\\nThe index.ts file till now looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import * as dotenv from \\\"dotenv\\\"\\ndotenv.config()\\nimport express, { Express } from \\\"express\\\"\\nimport mongoose from \\\"mongoose\\\"\\nimport { graphqlHTTP } from \\\"express-graphql\\\"\\nconst app: Express = express()\\nimport schema from \\\"./graphql/schemas\\\"\\nimport rootResolver from \\\"./graphql/resolvers\\\"\\n\\nconst PORT =\\n  process.env.NODE_ENV === \\\"production\\\"\\n    ? process.env.PORT\\n    : process.env.PORT_DEV\\n\\nconst MONGO_URI = process.env.MONGO_URI as string\\n\\napp.use(\\n  \\\"/graphql\\\",\\n  graphqlHTTP({\\n    schema: schema,\\n    rootValue: rootResolver,\\n    graphiql: true,\\n  })\\n)\\n\\nmongoose\\n  .connect(MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true })\\n  .then(() => {\\n    console.log(\\\"connected to mongodb...\\\")\\n    app.listen(PORT, () => {\\n      console.log(`server started on port ${PORT}`)\\n    })\\n  })\\n  .catch(err => {\\n    console.log(err)\\n  })\\n\")), mdx(Checkpoint, {\n    checkpoint: \"The code till now can be found here\",\n    repoLink: \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/graphql-creatUser-login-resolver-part-2\",\n    mdxType: \"Checkpoint\"\n  }), mdx(\"p\", null, \"Start the project and go to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://localhost:4000/graphql\"\n  }, \"http://localhost:4000/graphql\"), \". This is the playground where we will test our queries\\nand mutations. Later I will add a proper frontend using react-js. Let's test also with the queries and mutations\\nthat I have already written:\"), mdx(Video, {\n    videoSrcURL: \"https://drive.google.com/file/d/1J_HdBJ170wa29RiBLPDU1Hozqg1x6Yx0/preview\",\n    title: \"createUser and login mutation query test\",\n    mdxType: \"Video\"\n  }), mdx(\"p\", null, \"All queries and mutations used above are as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"# mutation to createUser\\n# mutation {\\n#   createUser(user: {username: \\\"john doe\\\", email: \\\"john@test.com\\\", password: \\\"test123\\\"}) {\\n#    _id\\n#     username\\n#     email\\n#     password\\n#     role\\n#   }\\n# }\\n\\n# mutation to check error for already created user\\n# mutation {\\n#   createUser(user: {username: \\\"john doe\\\", email: \\\"john@test.com\\\", password: \\\"test123\\\"}) {\\n#    _id\\n#     username\\n#     email\\n#     password\\n#     role\\n#   }\\n# }\\n\\n# mutation for login in user with email\\n# query{\\n#   login(usernameOrEmail:\\\"john@test.com\\\", password:\\\"test123\\\"){\\n#     userId\\n#     token\\n#     tokenExpiration\\n#   }\\n# }\\n\\n# mutation for login in user with username\\n# query{\\n#   login(usernameOrEmail:\\\"john doe\\\", password:\\\"test123\\\"){\\n#     userId\\n#     token\\n#     tokenExpiration\\n#   }\\n# }\\n\\n# mutation to check error with wrong email and password\\n# query{\\n#   login(usernameOrEmail:\\\"john doe\\\", password:\\\"test12345\\\"){\\n#     userId\\n#     token\\n#     tokenExpiration\\n#   }\\n# }\\n\")), mdx(\"p\", null, \"After running the createUser mutation above we have a user in our mongodb database as below:\\n\", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"674px\"\n    }\n  }, \"\\n      \", mdx(\"a\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/static/824df77c032ec4be3508f69e57476933/fdaf8/1.png\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": \"noopener\"\n  }, \"\\n    \", mdx(\"span\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"25.333333333333336%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAp0lEQVQY052QwWrDMBAF8/9/2IQeenFw3CaWZa9Wa3UnSI4hgZJDHwxvEWJY6QDw605OAvGGzyPEKx6+N8Zha4m4g7v/SU3tQx3MjHPX8XMZ6IcbMUyQ5cECplCMd9mlTaiqHE8nvroLH13gs5/ogzLn0ohakNrJGouuzGqNSYyU19cNSymMYWQRIVlhqZfTRp2rRPJKlE2ynzdxMtTKq/D5H/6b/cl3QpCIEFli6UgAAAAASUVORK5CYII=')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"a\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"created_user_in_db\",\n    \"title\": \"created_user_in_db\",\n    \"src\": \"/static/824df77c032ec4be3508f69e57476933/fdaf8/1.png\",\n    \"srcSet\": [\"/static/824df77c032ec4be3508f69e57476933/5a46d/1.png 300w\", \"/static/824df77c032ec4be3508f69e57476933/0a47e/1.png 600w\", \"/static/824df77c032ec4be3508f69e57476933/fdaf8/1.png 674w\"],\n    \"sizes\": \"(max-width: 674px) 100vw, 674px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  }), \"\\n  \"), \"\\n    \")), mdx(\"h3\", {\n    \"id\": \"adding-remaining-resolvers-related-to-users\"\n  }, \"Adding remaining resolvers related to users\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* listUsers resolver */\\nexport const listUsers = async () => {\\n  try {\\n    const users = await User.find()\\n    return users.map((user: UserType) => {\\n      return transformUser(user)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* getUserById resolver*/\\nexport const getUserById = async (args: { _id: string }) => {\\n  try {\\n    const user = await User.findById(args._id)\\n    return transformUser(user)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* deleteUser resolver */\\nexport const deleteUser = async (_id: string) => {\\n  try {\\n    await User.findByIdAndDelete(_id)\\n    return `user account removed successfully`\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* assignRole resolver */\\nexport const assignRole = async (args: {\\n  role: Role\\n  assignedBy: string\\n  assignedUser: string\\n}) => {\\n  try {\\n    const assigny = await User.findById(args.assignedBy)\\n    if (!assigny) {\\n      throw new Error(\\\"The user who is assigning role is not present in db\\\")\\n    }\\n\\n    const userToBeAssigned = await User.findById(args.assignedUser)\\n    if (userToBeAssigned._doc.role === \\\"ADMIN\\\")\\n      throw new Error(`User is already assigned ${args.role} role`)\\n\\n    const updatedUser = await User.updateOne(\\n      { _id: args.assignedUser },\\n      { $set: { role: args.role } }\\n    )\\n\\n    const result = await User.findById(args.assignedUser)\\n    return transformUser(result)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"p\", null, \"First let's test listUsers and getUserById:\"), mdx(Video, {\n    videoSrcURL: \"https://drive.google.com/file/d/19N4EAnoWOpryxEoOgecMUlv1pS8JPZvk/preview\",\n    title: \"listUsers/getUserById\",\n    mdxType: \"Video\"\n  }), mdx(Note, {\n    note: \"Note that for now there is no authorisation. Anyone can authorise any role to anyone. Also in case of posts and comments, anyone can  create posts or add comments. We will take care of authorisation in part-3\",\n    mdxType: \"Note\"\n  }), mdx(\"p\", null, \"Now Let's assign a new role to a user. I create a new user with the name of jane doe.We will assign a role of MODERATOR to jane doe.\\nFor now let's assume John doe was already an ADMIN. Later we will add authorisation logic to check weather a person\\nassigning a role to someone himself is ADMIN or not as told earlier!\"), mdx(Video, {\n    videoSrcURL: \"https://drive.google.com/file/d/15JtnN8_d21cNmKxCoG77pUGf48VYN5-B/preview\",\n    title: \"assignRole\",\n    mdxType: \"Video\"\n  }), mdx(\"p\", null, \"Now finally let's delete a user. Let's delete Jane Doe:\"), mdx(Video, {\n    videoSrcURL: \"https://drive.google.com/file/d/12rsEGZGko6sj87wg8e1ThAn8vAlQ7RP-/preview\",\n    title: \"deleteUser\",\n    mdxType: \"Video\"\n  }), mdx(\"p\", null, \"Seems like, all of our user resolvers works till now!\"), mdx(Checkpoint, {\n    checkpoint: \"The code till now can be found here\",\n    repoLink: \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/all-resolvers-related-to-users-part-2\",\n    mdxType: \"Checkpoint\"\n  }), mdx(\"h3\", {\n    \"id\": \"adding-resolvers-related-to-posts\"\n  }, \"Adding resolvers related to posts\"), mdx(\"p\", null, \"Let's first update the utils file where we add a few utility functions that will be used by\\nall resolvers related to posts.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* utils */\\n\\nimport User from \\\"../../models/User\\\"\\nimport Post from \\\"../../models/Post\\\"\\nimport { UserType } from \\\"./users\\\"\\nimport { PostType } from \\\"./posts\\\"\\n\\nexport const transformUser = (user: UserType) => {\\n  if (!user)\\n    return {\\n      _id: \\\"deleted_user\\\",\\n      email: \\\"deleted_user\\\",\\n      username: \\\"deleted_user\\\",\\n      role: \\\"deleted_user\\\",\\n      password: null,\\n      postList: [], // return empty array as user has been deleted!\\n      commentList: [], // return empty array as user has been deleted!\\n      likeList: [], // return empty array as user has been deleted!\\n      /* functionality can be increased so as all user's comments, likes or posts(for admins)\\n       could be deleted before the user itself is deleted from database  */\\n    }\\n  return {\\n    _id: user._id,\\n    username: user.username,\\n    email: user.email,\\n    role: user.role,\\n    password: null,\\n    postList: postsByCreatorId.bind(this, user._id!),\\n    commentList: [], // return empty array for now. we will add comments functionality in a bit\\n    likeList: [], // return empty array for now. we will add likes functionality in a bit\\n  }\\n}\\n\\nexport const transformPost = (post: PostType) => {\\n  return {\\n    _id: post._id,\\n    image: post.image,\\n    title: post.title,\\n    description: post.description,\\n    creator: singleUser.bind(this, post.creatorId),\\n    commentList: [], // return empty array for now. we will add comments functionality in a bit\\n    likeList: [], // return empty array for now. we will add likes functionality in a bit\\n  }\\n}\\n\\nexport const singleUser = async (userId: string) => {\\n  try {\\n    const user = await User.findById(userId)\\n    return transformUser(user)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\\nexport const postsByCreatorId = async (creatorId: string) => {\\n  try {\\n    const posts = await Post.find({ creatorId: creatorId })\\n    return posts.map((post: PostType) => {\\n      return transformPost(post)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"p\", null, \"Now we add all post resolvers:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* createPost resolver */\\nexport const createPost = async (args: PostArgsType) => {\\n  const post = new Post({\\n    image: args.post.image,\\n    title: args.post.title,\\n    description: args.post.description,\\n    creatorId: args.post.creatorId,\\n  })\\n\\n  try {\\n    const result = await post.save()\\n    return transformPost(result)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* deletePost resolver */\\nexport const deletePost = async (_id: string) => {\\n  try {\\n    await Post.findByIdAndDelete(_id)\\n    return `post removed successfully`\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* getPostById resolver */\\nexport const getPostById = async (args: { _id: string }) => {\\n  try {\\n    const post = await Post.findById(args._id)\\n    return transformPost(post)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* listPosts resolver*/\\nexport const listPosts = async () => {\\n  try {\\n    const posts = await Post.find()\\n    return posts.map((post: PostType) => {\\n      return transformPost(post)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"updating-the-root-resolver\"\n  }, \"updating the root resolver\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import * as usersResolver from \\\"./users\\\"\\nimport * as postsResolver from \\\"./posts\\\"\\n\\nconst rootResolver: any = {\\n  ...usersResolver,\\n  ...postsResolver,\\n}\\n\\nexport default rootResolver\\n\")), mdx(\"p\", null, \"Now we test the post resolvers. Let's say John Doe was creating, listing and deleting a few posts.\\nAssuming he is an ADMIN for now, ofcourse he can do such operations.\"), mdx(Video, {\n    videoSrcURL: \"https://drive.google.com/file/d/1CGPS5ST8lBHZgU4-tp_XxOxjXw5cfK4m/preview\",\n    title: \"create/delete/list-posts\",\n    mdxType: \"Video\"\n  }), mdx(Note, {\n    note: \"Do notice that now we can also\\nfetch the details of the user who created a post since we have already created all resolvers\\nrelated to users. Similary when we create resolvers of comments and likes, we will also be able\\nto fetch all comments and likes associated with each of the posts. Similar relationship will also\\nbe there for comments and likes. For eg. we will be able to fetch each like and the corrosponding\\nuser who created the like as well as the post on which like was added. You can imagine such nesting\\nwill keep on happening. Over here the power of graphql begins to shine!\\n\",\n    mdxType: \"Note\"\n  }), mdx(\"p\", null, \"We have successfully added posts resolver. Now since you have the idea how resolvers are being added, I\\nwould now add the comments and likes resolvers quickly. The structure and logic is pretty much similar\\nto that of posts. You can try that on your own. Again everything is defined already in graphql schema.\\nYou can refer to it whenever you are stuck and design resolvers according to that.\"), mdx(Checkpoint, {\n    checkpoint: \"The code till now can be found here\",\n    repoLink: \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/posts-all-resolvers-part-2\",\n    mdxType: \"Checkpoint\"\n  }), mdx(\"h3\", {\n    \"id\": \"adding-comments-resolvers\"\n  }, \"Adding comments resolvers\"), mdx(\"p\", null, \"First updating the utils file, we will need a couple of new utiltiy functions:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const transformUser = (user: UserType) => {\\n  if (!user)\\n    return {\\n      _id: \\\"deleted_user\\\",\\n      email: \\\"deleted_user\\\",\\n      username: \\\"deleted_user\\\",\\n      role: \\\"deleted_user\\\",\\n      password: null,\\n      postList: [], // return empty array as user has been deleted!\\n      commentList: [], // return empty array as user has been deleted!\\n      likeList: [], // return empty array as user has been deleted!\\n      /* functionality can be increased so as all user's comments, likes or posts(for admins)\\n       could be deleted before the user itself is deleted from database  */\\n    }\\n  return {\\n    _id: user._id,\\n    username: user.username,\\n    email: user.email,\\n    role: user.role,\\n    password: null,\\n    postList: postsByCreatorId.bind(this, user._id!),\\n    commentList: commentsByCreatorId.bind(this, user._id!),\\n    likeList: [], // return empty array for now. we will add likes functionality in a bit\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const transformPost = (post: PostType) => {\\n  return {\\n    _id: post._id,\\n    image: post.image,\\n    title: post.title,\\n    description: post.description,\\n    creator: singleUser.bind(this, post.creatorId),\\n    commentList: commentsByPostId.bind(this, post._id!),\\n    likeList: [], // return empty array for now. we will add likes functionality in a bit\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const transformComment = (comment: CommentType) => {\\n  return {\\n    _id: comment._id,\\n    text: comment.text,\\n    post: singlePost.bind(this, comment.postId),\\n    creator: singleUser.bind(this, comment.creatorId),\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const singlePost = async (postId: string) => {\\n  try {\\n    const post = await Post.findById(postId)\\n    return transformPost(post)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const commentsByPostId = async (postId: string) => {\\n  try {\\n    const comments = await Comment.find({ postId: postId })\\n    return comments.map((comment: CommentType) => {\\n      return transformComment(comment)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const commentsByCreatorId = async (creatorId: string) => {\\n  try {\\n    const comments = await Comment.find({ creatorId: creatorId })\\n    return comments.map((comment: CommentType) => {\\n      return transformComment(comment)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"p\", null, \"Now all the resolvers related to comments will be like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import Comment from \\\"../../../models/Comment\\\"\\nimport { transformComment } from \\\"../utils\\\"\\n\\nexport interface CommentType {\\n  _id: string\\n  text: string\\n  postId: string\\n  creatorId: string\\n}\\n\\ninterface CommentArgsType {\\n  comment: CommentType\\n}\\n\\nexport const listComments = async () => {\\n  try {\\n    const comments = await Comment.find()\\n    return comments.map((comment: CommentType) => {\\n      return transformComment(comment)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\\nexport const getCommentById = async (args: { _id: string }) => {\\n  try {\\n    const comment = await Comment.findById(args._id)\\n    return transformComment(comment)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\\nexport const createComment = async (args: CommentArgsType) => {\\n  const comment = new Comment({\\n    text: args.comment.text,\\n    postId: args.comment.postId,\\n    creatorId: args.comment.creatorId,\\n  })\\n\\n  try {\\n    const result = await comment.save()\\n    return transformComment(result)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\\nexport const deleteComment = async (_id: string) => {\\n  try {\\n    await Comment.findByIdAndDelete(_id)\\n    return `comment removed successfully`\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"updating-the-root-resolver-file-again\"\n  }, \"updating the root resolver file again:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import * as usersResolver from \\\"./users\\\"\\nimport * as postsResolver from \\\"./posts\\\"\\nimport * as commentsResolver from \\\"./comments\\\"\\n\\nconst rootResolver: any = {\\n  ...usersResolver,\\n  ...postsResolver,\\n  ...commentsResolver,\\n}\\n\\nexport default rootResolver\\n\")), mdx(\"p\", null, \"Now let's test the comments resolver. For this I have already created 2 new users and 2 new posts. Then I will add\\n1 comment to each of the posts.\"), mdx(Video, {\n    videoSrcURL: \"https://drive.google.com/file/d/1qcpRmS5VRVHVLLZzAK-Shhs222z7RMOF/preview\",\n    title: \"create/delete/list-comments\",\n    mdxType: \"Video\"\n  }), mdx(Checkpoint, {\n    checkpoint: \"The code till now can be found here\",\n    repoLink: \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/all-comments-resolvers-part-2\",\n    mdxType: \"Checkpoint\"\n  }), mdx(\"h3\", {\n    \"id\": \"adding-likes-resolvers\"\n  }, \"Adding likes resolvers\"), mdx(\"p\", null, \"First updating the utils file, we will need 2 new functions:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const transformPost = (post: PostType) => {\\n  return {\\n    _id: post._id,\\n    image: post.image,\\n    title: post.title,\\n    description: post.description,\\n    creator: singleUser.bind(this, post.creatorId),\\n    commentList: commentsByPostId.bind(this, post._id!),\\n    likeList: likesByPostId.bind(this, post._id!),\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const transformComment = (comment: CommentType) => {\\n  return {\\n    _id: comment._id,\\n    text: comment.text,\\n    post: singlePost.bind(this, comment.postId),\\n    creator: singleUser.bind(this, comment.creatorId),\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const transformLike = (like: LikeType) => {\\n  return {\\n    _id: like._id,\\n    post: singlePost.bind(this, like.postId),\\n    creator: singleUser.bind(this, like.creatorId),\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const likesByPostId = async (postId: string) => {\\n  try {\\n    const likes = await Like.find({ postId: postId })\\n    return likes.map((like: any) => {\\n      return transformLike(like)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export const likesByCreatorId = async (creatorId: string) => {\\n  try {\\n    const likes = await Like.find({ creatorId: creatorId })\\n    return likes.map((like: LikeType) => {\\n      return transformLike(like)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"p\", null, \"Now all the resolvers related to likes will be like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import Like from \\\"../../../models/Like\\\"\\nimport { transformLike } from \\\"../utils\\\"\\n\\nexport interface LikeType {\\n  _id?: string\\n  postId: string\\n  creatorId: string\\n}\\n\\ninterface LikeArgsType {\\n  like: LikeType\\n}\\n\\nexport const listLikes = async () => {\\n  try {\\n    const likes = await Like.find()\\n    return likes.map((like: LikeType) => {\\n      return transformLike(like)\\n    })\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\\nexport const getLikeById = async (args: { _id: string }) => {\\n  try {\\n    const like = await Like.findById(args._id)\\n    return transformLike(like)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\\nexport const createLike = async (args: LikeArgsType) => {\\n  const like = new Like({\\n    postId: args.like.postId,\\n    creatorId: args.like.creatorId,\\n  })\\n\\n  try {\\n    const result = await like.save()\\n    return transformLike(result)\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\\nexport const deleteLike = async (_id: string) => {\\n  try {\\n    await Like.findByIdAndDelete(_id)\\n    return `like removed successfully`\\n  } catch (error) {\\n    throw error\\n  }\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"updating-the-root-resolver-file-again-1\"\n  }, \"updating the root resolver file again:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import * as usersResolver from \\\"./users\\\"\\nimport * as postsResolver from \\\"./posts\\\"\\nimport * as commentsResolver from \\\"./comments\\\"\\nimport * as likesResolver from \\\"./likes\\\"\\n\\nconst rootResolver: any = {\\n  ...usersResolver,\\n  ...postsResolver,\\n  ...commentsResolver,\\n  ...likesResolver,\\n}\\n\\nexport default rootResolver\\n\")), mdx(\"p\", null, \"I won't be testing all likes resolver because the implementation is very much like comments.\\nYou can try this part on your own.\"), mdx(Checkpoint, {\n    checkpoint: \"The code till now can be found here\",\n    repoLink: \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/all-likes-resolvers-part-2\",\n    mdxType: \"Checkpoint\"\n  }), mdx(\"p\", null, \"You can view Part 3 of the series here: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"/custom-directives-with-express-graphql-part-3\"\n  }, \"part 3 ->\")));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#defining-graphql-schema","title":"Defining graphql schema"},{"url":"#implementing-resolvers","title":"Implementing resolvers"},{"url":"#creating-the-utilities-file-","title":"Creating the utilities file ðŸš€"},{"url":"#creating-createuser--login-resolver","title":"Creating createUser & login resolver"},{"url":"#adding-the-root-resolver","title":"Adding the root resolver"},{"url":"#updating-the-root-indexts-fileentry-point","title":"updating the root index.ts file(entry point)"},{"url":"#adding-remaining-resolvers-related-to-users","title":"Adding remaining resolvers related to users"},{"url":"#adding-resolvers-related-to-posts","title":"Adding resolvers related to posts"},{"url":"#updating-the-root-resolver","title":"updating the root resolver"},{"url":"#adding-comments-resolvers","title":"Adding comments resolvers"},{"url":"#updating-the-root-resolver-file-again","title":"updating the root resolver file again:"},{"url":"#adding-likes-resolvers","title":"Adding likes resolvers"},{"url":"#updating-the-root-resolver-file-again-1","title":"updating the root resolver file again:"}]},"headings":[{"depth":3,"value":"Defining graphql schema"},{"depth":3,"value":"Implementing resolvers"},{"depth":3,"value":"Creating the utilities file ðŸš€"},{"depth":3,"value":"Creating createUser & login resolver"},{"depth":3,"value":"Adding the root resolver"},{"depth":3,"value":"updating the root index.ts file(entry point)"},{"depth":3,"value":"Adding remaining resolvers related to users"},{"depth":3,"value":"Adding resolvers related to posts"},{"depth":3,"value":"updating the root resolver"},{"depth":3,"value":"Adding comments resolvers"},{"depth":3,"value":"updating the root resolver file again:"},{"depth":3,"value":"Adding likes resolvers"},{"depth":3,"value":"updating the root resolver file again:"}],"frontmatter":{"date":"29-06-2021","excerpt":"Adding graphql schema and resolvers.","slug":"custom-directives-with-express-graphql-part-2","title":"Custom directives with express-graphql [Part-2]","featureImage":{"publicURL":"/static/1b289d874439805d34eead0c1756920b/feature.jpg","childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAEDBf/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAABy6yMRiD/xAAZEAACAwEAAAAAAAAAAAAAAAAAAgERICH/2gAIAQEAAQUCGSieY//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABgQAAIDAAAAAAAAAAAAAAAAAAABESAi/9oACAEBAAY/AhaTmv8A/8QAGhABAAEFAAAAAAAAAAAAAAAAEQABICFBUf/aAAgBAQABPyEnDBxqUIs//9oADAMBAAIAAwAAABDAD//EABYRAAMAAAAAAAAAAAAAAAAAAAEQYf/aAAgBAwEBPxAxf//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAQEAAQUAAAAAAAAAAAAAAAERACAxQXGR/9oACAEBAAE/ECi0O8MztsvDl2hnJo//2Q==","aspectRatio":1.5384615384615385,"src":"/static/1b289d874439805d34eead0c1756920b/14b42/feature.jpg","srcSet":"/static/1b289d874439805d34eead0c1756920b/f836f/feature.jpg 200w,\n/static/1b289d874439805d34eead0c1756920b/2244e/feature.jpg 400w,\n/static/1b289d874439805d34eead0c1756920b/14b42/feature.jpg 800w,\n/static/1b289d874439805d34eead0c1756920b/47498/feature.jpg 1200w,\n/static/1b289d874439805d34eead0c1756920b/0e329/feature.jpg 1600w,\n/static/1b289d874439805d34eead0c1756920b/ee1b0/feature.jpg 1721w","sizes":"(max-width: 800px) 100vw, 800px"}}}}}},"pageContext":{"id":"9c5a5246-0d1e-570d-b67a-062c157cebe1"}},"staticQueryHashes":["2933417362","3079204723"]}