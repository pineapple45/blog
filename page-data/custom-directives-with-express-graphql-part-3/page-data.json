{"componentChunkName":"component---src-templates-single-post-js","path":"/custom-directives-with-express-graphql-part-3","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Custom directives with express-graphql [Part-3]\",\n  \"slug\": \"custom-directives-with-express-graphql-part-3\",\n  \"date\": \"29-06-2021\",\n  \"featureImage\": \"feature.jpg\",\n  \"excerpt\": \"Adding custom directives using express-graphql and graphql-directive.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Till now we have the application structure fully setup.\\nFinal code can be found here: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/schema-splitting-part-3\"\n  }, \"Link\")), mdx(\"p\", null, \"There are only 2 main things left:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Authentication\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Authorisation\")), mdx(\"p\", null, \"We will be using JWT authentication method for loging in the user.\"), mdx(\"h3\", {\n    \"id\": \"choosing-a-wise-logic-for-authentication--authorisation\"\n  }, \"Choosing a wise logic for authentication & authorisation\"), mdx(\"p\", null, \"If you have worked with REST API, it is easier to work implement both of the functionalities. We can just\\ncreate a middleware and apply the same middleware to each of the routes(\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"get\"), \" requests) that we either want\\nto authenticate or on top of that authorize. But how will we implement that in graphql ? We have only a single\\nroute 'http://whatever_host_url/graphql'. We are left with 2 choices.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Either attach a special property to each incoming request and then check in each of the resolver\\nfunctions(users, posts, comments, likes) weather the resolver should fulfill the request or not!\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Attatch custom resolver directly to each of our query , mutation or type definations in our graphql\\nschema. Each custom resolver will have a seperate implementation logic where it will be checked weather\\nthe request should even reach the resolver or not?\")), mdx(\"p\", null, \"Now both the methods can be used. But personally I would prefer to go with second one. I think this is\\na good approach because this approach has quite a lot of benefits. The most visible ones are:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Code becomes much more modular. Write less code with same functionality!\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Attatching a special property to each incoming request and then check where request should be\\nfullfilled or not inside the resolver is cumbersome. As you can imagine when projects become larger, the resolvers\\nwill also increase. Managing logic for authentication/authorisation becomes really tedious and it may happen that\\nyou may forget adding this logic in some resolvers. The first approach is good enough for smaller projects.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Proved a REST like architecture. It kind of takes a middleware approach very similar to REST as you will\\nsee in a bit.\")), mdx(\"h3\", {\n    \"id\": \"installing-graphql-directive-package\"\n  }, \"Installing graphql-directive package\"), mdx(\"p\", null, \"If you havent already, download the graphql-directive package.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cmd\"\n  }, \"yarn add graphql-directive\\n// or\\nnpm i graphql-directive\\n\")), mdx(Note, {\n    note: \" please not the version number for 'graphql' package and to specifically use this one\\nas I was having a couple of problems with newer version of 'graphql' package.\\n'graphql': '14.6.0'\",\n    mdxType: \"Note\"\n  }), mdx(\"h3\", {\n    \"id\": \"adding-types-for-graphql-directive-package\"\n  }, \"Adding types for graphql-directive package\"), mdx(\"p\", null, \"Since no type are available for graphql-directive package that we installed, we create a graphql-directive.d.ts file in the root\\nwith content as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"declare module \\\"graphql-directive\\\"\\n\")), mdx(\"h3\", {\n    \"id\": \"adding-graphql-directive-resolvers\"\n  }, \"Adding graphql-directive resolvers\"), mdx(\"p\", null, \"folder structure is as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"-src\\n--graphql\\n---directives\\n----hasAuthorisation\\n----isAuthenticated\\n----upperCase\\n----index.ts\\n.\\n.\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* hasAuthorisation */\\nimport jwt from \\\"jsonwebtoken\\\"\\n\\nexport const hasAuthorisation = async (\\n  resolve: any,\\n  directiveArgs: any,\\n  obj: any,\\n  context: any,\\n  info: any\\n) => {\\n  const authHeader = context.req.get(\\\"authorization\\\")\\n  console.log(authHeader)\\n  if (authHeader === undefined || context.authHeader === \\\"\\\")\\n    throw new Error(`you are unauthenticated`)\\n\\n  const token = authHeader.split(\\\" \\\")[1]\\n  if (!token || token === \\\"\\\") throw new Error(\\\"Token not found or has expired\\\")\\n\\n  let decodedToken: any\\n  try {\\n    decodedToken = jwt.verify(token, process.env.JWT_SECRET_KEY as string)\\n  } catch (error: any) {\\n    if (!token || token === \\\"\\\") throw new Error(error)\\n  }\\n\\n  if (!decodedToken) throw new Error(\\\"Token verification failed\\\")\\n\\n  // check authorisation roles here\\n  const roleToCheckFrom = obj && obj.roles\\n  if (roleToCheckFrom.indexOf(decodedToken.role) === -1)\\n    throw new Error(\\\"Not Authorised\\\")\\n  return resolve()\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* isAuthenticated */\\nimport jwt from \\\"jsonwebtoken\\\"\\n\\nexport const isAuthenticated = async (\\n  resolve: any,\\n  directiveArgs: any,\\n  obj: any,\\n  context: any,\\n  info: any\\n) => {\\n  // console.log(context.req);\\n  const authHeader = context.req.get(\\\"Authorization\\\")\\n  console.log(authHeader)\\n  if (authHeader === undefined || context.authHeader === \\\"\\\")\\n    throw new Error(`you are unauthenticated`)\\n\\n  const token = authHeader.split(\\\" \\\")[1]\\n  if (!token || token === \\\"\\\") throw new Error(\\\"Token not found or has expired\\\")\\n\\n  let decodedToken: any\\n  try {\\n    decodedToken = jwt.verify(token, process.env.JWT_SECRET_KEY as string)\\n  } catch (error: any) {\\n    if (!token || token === \\\"\\\") throw new Error(error)\\n  }\\n\\n  if (!decodedToken) throw new Error(\\\"Token verification failed\\\")\\n\\n  return resolve()\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* upperCase */\\nexport const upperCase = async (\\n  resolve: any,\\n  directiveArgs: any,\\n  obj: any,\\n  context: any,\\n  info: any\\n) => {\\n  const value = await resolve()\\n  return String(value).toUpperCase()\\n}\\n\")), mdx(Note, {\n    note: \"Note that @hasAuthorisation directive also covers the logic for @isAuthenticated. So while using \\nthe @hasAuthorisation directive, even if the user is the correctly authorised one, if user is not authenticated or \\nas I should say the request header is empty, graphql will give error message of --not authenticated \",\n    mdxType: \"Note\"\n  }), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* ../graphql/directives/index.ts*/\\nexport * from \\\"./hasAuthorisation\\\"\\nexport * from \\\"./isAuthenticated\\\"\\nexport * from \\\"./upperCase\\\"\\n\")), mdx(Checkpoint, {\n    checkpoint: \"The code till now can be found here\",\n    repoLink: \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/all-directive-resolvers-part-3\",\n    mdxType: \"Checkpoint\"\n  }), mdx(\"h3\", {\n    \"id\": \"updating-graphql-schema-file-to-handle-custom-directives\"\n  }, \"updating graphql-schema file to handle custom directives\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { buildSchema } from \\\"graphql\\\"\\nimport { addDirectiveResolveFunctionsToSchema } from \\\"graphql-directive\\\"\\nimport { upperCase, isAuthenticated, hasAuthorisation } from \\\"../directives\\\"\\n\\nconst schema = buildSchema(`\\n\\ndirective @upperCase on FIELD_DEFINITION | FIELD\\ndirective @isAuthenticated on FIELD_DEFINITION | FIELD\\ndirective @hasAuthorisation(roles: [Role!]) on FIELD_DEFINITION | FIELD\\n\\ninput PostInput {\\n    image: String\\n    title: String!\\n    description: String\\n    creatorId: ID!\\n}\\n\\ntype Post {\\n    _id: ID!\\n    image: String\\n    title: String!\\n    description: String\\n    creator: User!\\n    commentList: [Comment!]\\n    likeList: [Like!]\\n}\\n\\ninput CommentInput {\\n    text: String!\\n    postId: ID!\\n    creatorId: ID!\\n}\\n\\ntype Comment {\\n    _id: ID!\\n    text: String!\\n    post: Post!\\n    creator: User!\\n}\\n\\ninput LikeInput {\\n    postId: ID!\\n    creatorId: ID!\\n}\\n\\ntype Like {\\n    _id: ID!\\n    post: Post!\\n    creator: User!\\n}\\n\\nenum Role {\\n    AUTH_USER\\n    ADMIN\\n    MODERATOR\\n}\\n\\ninput UserInput {\\n    username: String!\\n    email: String!\\n    password: String!\\n}\\n\\ntype User {\\n    _id: ID!\\n    username: String! @upperCase\\n    email: String!\\n    password: String\\n    role: Role!\\n    postList: [Post!]\\n    commentList: [Comment!]\\n    likeList: [Like!]\\n}\\n\\ntype AuthData {\\n    userId: ID!\\n    token: String!\\n    tokenExpiration: Int!\\n}\\n\\ntype RootQuery {\\n  listUsers: [User!] @hasAuthorisation(roles: [ADMIN])\\n  getUserById(_id: ID!): User!\\n  listPosts: [Post!]\\n  getPostById(_id: ID!): Post!\\n  listComments: [Comment!]\\n  getCommentById(_id: ID!): Comment!\\n  listLikes: [Like!]\\n  getLikeById(_id: ID!): Like!\\n  login(usernameOrEmail: String!, password: String!): AuthData!\\n}\\n\\ntype RootMutation {\\n  createUser(user: UserInput): User\\n  deleteUser(_id: ID!): String @hasAuthorisation(roles: [ADMIN])\\n  createPost(post: PostInput): Post @hasAuthorisation(roles: [ADMIN])\\n  deletePost(_id: ID!): String @hasAuthorisation(roles: [ADMIN,MODERATOR])\\n  createComment(comment: CommentInput): Comment\\n  deleteComment(_id: ID!): String @hasAuthorisation(roles: [ADMIN,MODERATOR])\\n  createLike(like: LikeInput): Like\\n  deleteLike(_id: ID!): String\\n  assignRole(role: String! , assignedBy: ID!, assignedUser: ID!): User @hasAuthorisation(roles: [ADMIN])\\n}\\n\\nschema {\\n  query: RootQuery\\n  mutation: RootMutation\\n}\\n`)\\n\\naddDirectiveResolveFunctionsToSchema(schema, {\\n  upperCase,\\n  isAuthenticated,\\n  hasAuthorisation,\\n})\\n\\nexport default schema\\n\")), mdx(\"h3\", {\n    \"id\": \"updating-entry-srcindexts-file-to-pass-graphql-context-to-each-of-the-directive-resolvers\"\n  }, \"updating entry src/index.ts file to pass graphql context to each of the directive-resolvers\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import * as dotenv from \\\"dotenv\\\"\\ndotenv.config()\\nimport cors from \\\"cors\\\"\\nimport express, { Express, Request, Response, NextFunction } from \\\"express\\\"\\nimport { graphqlHTTP } from \\\"express-graphql\\\"\\nimport schema from \\\"./graphql/schemas\\\"\\nimport rootResolver from \\\"./graphql/resolvers\\\"\\nimport mongoose from \\\"mongoose\\\"\\nconst app: Express = express()\\n\\napp.use(cors())\\n\\napp.use((req: Request, res: Response, next: NextFunction) => {\\n  res.setHeader(\\\"Access-Control-Allow-Origin\\\", \\\"*\\\")\\n  res.setHeader(\\\"Access-Control-Allow-Methods\\\", \\\"POST,GET,OPTIONS\\\")\\n  res.setHeader(\\\"Access-Control-Allow-Headers\\\", \\\"Content-Type, Authorization\\\")\\n  if (req.method === \\\"OPTIONS\\\") {\\n    return res.sendStatus(200)\\n  }\\n  next()\\n})\\n\\napp.use(\\\"/graphql\\\", (req, res) => {\\n  return graphqlHTTP({\\n    schema: schema,\\n    rootValue: rootResolver,\\n    graphiql: true,\\n    context: { req, res }, // we pass context here which will be received by aur directive resolvers\\n  })(req, res)\\n})\\n\\nconst PORT =\\n  process.env.NODE_ENV === \\\"production\\\"\\n    ? process.env.PORT\\n    : process.env.PORT_DEV\\n\\nconst MONGO_URI = process.env.MONGO_URI as string\\n\\nmongoose\\n  .connect(MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true })\\n  .then(() => {\\n    console.log(\\\"connected to mongodb...\\\")\\n    app.listen(PORT, () => {\\n      console.log(`server started on port ${PORT}`)\\n    })\\n  })\\n  .catch(err => {\\n    console.log(err)\\n  })\\n\")), mdx(Checkpoint, {\n    checkpoint: \"The code till now can be found here\",\n    repoLink: \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/full-directives-implementation-part-3\",\n    mdxType: \"Checkpoint\"\n  }), mdx(\"p\", null, \"Now let's test our custom directives. If you take a look at the updated schema, we have out directives placed\\nat a few different places.\"), mdx(\"p\", null, \"As told above in the note, @hasAuthorisation directive also covers the logic for @isAuthenticated directive.\\nWe will test the @hasAuthorisation for both authentication and authorisation.\"), mdx(Note, {\n    note: \"We cannot use graphiql tool for testing these directives since we need to pass headers along with\\nour requests which we want to be either authorised or authenticated. So we will use POSTMAN tool for this purpose.\\nThe syntex for setting up queries in POSTMAN is a bit weird, So watch the video below carefully! \",\n    mdxType: \"Note\"\n  }), mdx(\"h4\", {\n    \"id\": \"testing-the-isauthenticated--hasauthorisation-directive\"\n  }, \"Testing the @isAuthenticated & @hasAuthorisation directive\"), mdx(\"p\", null, \"First we will send no headers.We will try to list all users. In this case we should get \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"you are unauthenticated\"), \" error message as specified in our\\n@hasAuthorisation and @isAuthenticated custom-directive resolvers.\"), mdx(Video, {\n    videoSrcURL: \"https://drive.google.com/file/d/1ErVDtA_o92ZJoc9h_Ub7CoC5lEONl3_s/preview\",\n    title: \"@isAuthenticated-@hasAuthorisation\",\n    mdxType: \"Video\"\n  }), mdx(\"p\", null, \"We get \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"you are unauthenticated\"), \" which means @isAuthenticated directive is correctly setup. It also means\\nthat @hasAuthorisation directive is also correctly setup as long as authentication is concerned.\"), mdx(\"h4\", {\n    \"id\": \"testing-hasauthorisation-directive\"\n  }, \"Testing @hasAuthorisation directive\"), mdx(\"p\", null, \"Now we will take care of authorisation part in @hasAuthorisation. First we will log in. We get the Json Web Token.\\nThen we use the token and send it along the header and then our custom directive resolver handles authorisation. We currently have no user who is an\\nADMIN or MODERATOR. So as per the schema and custom directives defined in it, if we try to get a list of all\\nusers, we should get \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Not Authorised\"), \".\"), mdx(Video, {\n    videoSrcURL: \"https://drive.google.com/file/d/1-GuqF2QQPC2N4V0ZknYwmuynvwxPn70F/preview\",\n    title: \"@hasAuthorisation\",\n    mdxType: \"Video\"\n  }), mdx(\"h4\", {\n    \"id\": \"testing-the-uppercase-directive\"\n  }, \"Testing the @upperCase directive\"), mdx(\"p\", null, \"Now to test @upperCase directive, we need to get the list of all users since each username has to be shown in\\nuppercase as per our graphql schema. User's list can only be retrieved by an ADMIN. So I will manually\\nupdate the user role of any one of the user's in our mongodb database to ADMIN. Lets update role of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"john doe\"), \" token\\nADMIN:\"), mdx(Video, {\n    videoSrcURL: \"https://drive.google.com/file/d/1JuIr-cC6LL5C07_NsToe2zZ5rebTpJKY/preview\",\n    title: \"@update_role_to_ADMIN\",\n    mdxType: \"Video\"\n  }), mdx(\"p\", null, \"Now since role of user \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"john doe\"), \" is updated to ADMIN, john should be able to retrieve the list of users\\nsuccessfully. We should also get usernames in uppercase which will confirm that our @upperCase directive is\\nworking fine:\"), mdx(Video, {\n    videoSrcURL: \"https://drive.google.com/file/d/1SqXxogME15UbnyfSZKGkkDcMARAToyXD/preview\",\n    title: \"@upperCase\",\n    mdxType: \"Video\"\n  }), \"So finally we get the response that we were looking for and hence this confirms that our custom directives are working as they should....\\uD83C\\uDF89\\uD83C\\uDF89\\uD83C\\uDF89\\uD83C\\uDF89\\uD83C\\uDF89\", mdx(\"h3\", {\n    \"id\": \"splitting-our-graphql-schemaoptional\"\n  }, \"Splitting our graphql schema(optional)\"), mdx(\"p\", null, \"Now our schema is getting a bit long. As the project grows, it is better to divide the schema\\nbased on different sub-queries,sub-mutations or sub-subscriptions.\\nIf you want to see how this is done a greater detail, watch this awesome video by ben awad: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=4XmQi80nFes\"\n  }, \"Link\")), mdx(\"h3\", {\n    \"id\": \"updated-directory-structure-for-schemas-folder\"\n  }, \"Updated directory structure for schemas folder\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"-src\\n--graphql\\n---schemas\\n----users.ts\\n----posts.ts\\n----comments.ts\\n----likes.ts\\n----index.ts\\n.\\n.\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* ../graphql/schemas/users.ts */\\nexport const types = `\\ntype User {\\n    _id: ID!\\n    username: String! @upperCase\\n    email: String!\\n    password: String\\n    role: Role!\\n    postList: [Post!]\\n    commentList: [Comment!]\\n    likeList: [Like!]\\n} \\n\\ntype AuthData {\\n    userId: ID!\\n    token: String!\\n    tokenExpiration: Int!\\n}\\n\\ninput UserInput {\\n    username: String!\\n    email: String!\\n    password: String!\\n}\\n`\\n\\nexport const queries = `\\nlistUsers: [User!] @hasAuthorisation(roles: [ADMIN])  \\ngetUserById(_id: ID!): User! \\nlogin(usernameOrEmail: String!, password: String!): AuthData!\\n`\\n\\nexport const mutations = `\\ncreateUser(user: UserInput): User\\n  deleteUser(_id: ID!): String @hasAuthorisation(roles: [ADMIN])\\n  assignRole(role: String! , assignedBy: ID!, assignedUser: ID!): User @hasAuthorisation(roles: [ADMIN])\\n\\n`\\n\\nexport const subscriptions = ``\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* ../graphql/schemas/posts.ts */\\nexport const types = `\\ninput PostInput {\\n    image: String\\n    title: String!\\n    description: String\\n    creatorId: ID!\\n}\\n\\ntype Post {\\n    _id: ID!\\n    image: String\\n    title: String!\\n    description: String\\n    creator: User!\\n    commentList: [Comment!]\\n    likeList: [Like!]\\n}\\n`\\n\\nexport const queries = `\\nlistPosts: [Post!]\\ngetPostById(_id: ID!): Post!\\n`\\n\\nexport const mutations = `\\ncreatePost(post: PostInput): Post @hasAuthorisation(roles: [ADMIN])\\n  deletePost(_id: ID!): String @hasAuthorisation(roles: [ADMIN,MODERATOR])\\n`\\n\\nexport const subscriptions = ``\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* ../graphql/schemas/comments.ts */\\nexport const types = `\\ninput CommentInput {\\n    text: String!\\n    postId: ID!\\n    creatorId: ID!\\n}\\n\\ntype Comment {\\n    _id: ID!\\n    text: String!\\n    post: Post!\\n    creator: User!\\n}\\n`\\n\\nexport const queries = `\\nlistComments: [Comment!]\\ngetCommentById(_id: ID!): Comment! \\n`\\n\\nexport const mutations = `\\ncreateComment(comment: CommentInput): Comment\\n  deleteComment(_id: ID!): String @hasAuthorisation(roles: [ADMIN,MODERATOR])\\n`\\n\\nexport const subscriptions = ``\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* ../graphql/schemas/likes.ts */\\nexport const types = `\\ninput LikeInput { \\n    postId: ID!\\n    creatorId: ID!\\n}\\n\\ntype Like {\\n    _id: ID!\\n    post: Post!\\n    creator: User!\\n}\\n`\\n\\nexport const queries = `\\n  listLikes: [Like!]\\n  getLikeById(_id: ID!): Like!\\n`\\n\\nexport const mutations = `\\ncreateLike(like: LikeInput): Like\\n  deleteLike(_id: ID!): String\\n`\\n\\nexport const subscriptions = ``\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* ../graphql/schemas/index.ts */\\n//\\nimport { buildSchema } from \\\"graphql\\\"\\nimport { addDirectiveResolveFunctionsToSchema } from \\\"graphql-directive\\\"\\nimport { upperCase, isAuthenticated, hasAuthorisation } from \\\"../directives\\\"\\n\\n// import comparted schemas\\nimport * as postsGQLSchema from \\\"./posts\\\"\\nimport * as commentsGQLSchema from \\\"./comments\\\"\\nimport * as likesGQLSchema from \\\"./likes\\\"\\nimport * as usersGQLSchema from \\\"./users\\\"\\n\\nconst types: string[] = []\\nconst queries: string[] = []\\nconst mutations: string[] = []\\nconst subscriptions = []\\nconst schemas = [\\n  postsGQLSchema,\\n  commentsGQLSchema,\\n  likesGQLSchema,\\n  usersGQLSchema,\\n]\\n\\nschemas.forEach(schema => {\\n  types.push(schema.types)\\n  queries.push(schema.queries)\\n  mutations.push(schema.mutations)\\n  subscriptions.push(schema.subscriptions)\\n})\\n\\nconst schema = buildSchema(`\\n\\ndirective @upperCase on FIELD_DEFINITION | FIELD\\ndirective @isAuthenticated on FIELD_DEFINITION | FIELD\\ndirective @hasAuthorisation(roles: [Role!]) on FIELD_DEFINITION | FIELD\\n\\nenum Role {\\n    AUTH_USER\\n    ADMIN\\n    MODERATOR\\n}\\n\\n${types.join(\\\"\\\\n\\\")}\\n\\n\\ntype RootQuery {\\n    ${queries.join(\\\"\\\\n\\\")}\\n}\\n\\ntype RootMutation {\\n${mutations.join(\\\"\\\\n\\\")}\\n}\\n\\nschema {\\n  query: RootQuery\\n  mutation: RootMutation\\n}\\n`)\\n\\naddDirectiveResolveFunctionsToSchema(schema, {\\n  upperCase,\\n  isAuthenticated,\\n  hasAuthorisation,\\n})\\n\\nexport default schema\\n\")), mdx(\"p\", null, \"I will leave the original schema in a reference.ts file so as to later reference in case needed.\"), mdx(Checkpoint, {\n    checkpoint: \"The code till now can be found here\",\n    repoLink: \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/schema-splitting-part-3\",\n    mdxType: \"Checkpoint\"\n  }), mdx(\"h3\", {\n    \"id\": \"final-points\"\n  }, \"final points\"), mdx(Gif, {\n    gifUrl: \"https://media.giphy.com/media/3otPoS81loriI9sO8o/giphy.gif\",\n    mdxType: \"Gif\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#choosing-a-wise-logic-for-authentication--authorisation","title":"Choosing a wise logic for authentication & authorisation"},{"url":"#installing-graphql-directive-package","title":"Installing graphql-directive package"},{"url":"#adding-types-for-graphql-directive-package","title":"Adding types for graphql-directive package"},{"url":"#adding-graphql-directive-resolvers","title":"Adding graphql-directive resolvers"},{"url":"#updating-graphql-schema-file-to-handle-custom-directives","title":"updating graphql-schema file to handle custom directives"},{"url":"#updating-entry-srcindexts-file-to-pass-graphql-context-to-each-of-the-directive-resolvers","title":"updating entry src/index.ts file to pass graphql context to each of the directive-resolvers","items":[{"url":"#testing-the-isauthenticated--hasauthorisation-directive","title":"Testing the @isAuthenticated & @hasAuthorisation directive"},{"url":"#testing-hasauthorisation-directive","title":"Testing @hasAuthorisation directive"},{"url":"#testing-the-uppercase-directive","title":"Testing the @upperCase directive"}]},{"url":"#splitting-our-graphql-schemaoptional","title":"Splitting our graphql schema(optional)"},{"url":"#updated-directory-structure-for-schemas-folder","title":"Updated directory structure for schemas folder"},{"url":"#final-points","title":"final points"}]},"headings":[{"depth":3,"value":"Choosing a wise logic for authentication & authorisation"},{"depth":3,"value":"Installing graphql-directive package"},{"depth":3,"value":"Adding types for graphql-directive package"},{"depth":3,"value":"Adding graphql-directive resolvers"},{"depth":3,"value":"updating graphql-schema file to handle custom directives"},{"depth":3,"value":"updating entry src/index.ts file to pass graphql context to each of the directive-resolvers"},{"depth":4,"value":"Testing the @isAuthenticated & @hasAuthorisation directive"},{"depth":4,"value":"Testing @hasAuthorisation directive"},{"depth":4,"value":"Testing the @upperCase directive"},{"depth":3,"value":"Splitting our graphql schema(optional)"},{"depth":3,"value":"Updated directory structure for schemas folder"},{"depth":3,"value":"final points"}],"frontmatter":{"date":"29-06-2021","excerpt":"Adding custom directives using express-graphql and graphql-directive.","slug":"custom-directives-with-express-graphql-part-3","title":"Custom directives with express-graphql [Part-3]","featureImage":{"publicURL":"/static/1b289d874439805d34eead0c1756920b/feature.jpg","childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAEDBf/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAABy6yMRiD/xAAZEAACAwEAAAAAAAAAAAAAAAAAAgERICH/2gAIAQEAAQUCGSieY//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABgQAAIDAAAAAAAAAAAAAAAAAAABESAi/9oACAEBAAY/AhaTmv8A/8QAGhABAAEFAAAAAAAAAAAAAAAAEQABICFBUf/aAAgBAQABPyEnDBxqUIs//9oADAMBAAIAAwAAABDAD//EABYRAAMAAAAAAAAAAAAAAAAAAAEQYf/aAAgBAwEBPxAxf//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAQEAAQUAAAAAAAAAAAAAAAERACAxQXGR/9oACAEBAAE/ECi0O8MztsvDl2hnJo//2Q==","aspectRatio":1.5384615384615385,"src":"/static/1b289d874439805d34eead0c1756920b/14b42/feature.jpg","srcSet":"/static/1b289d874439805d34eead0c1756920b/f836f/feature.jpg 200w,\n/static/1b289d874439805d34eead0c1756920b/2244e/feature.jpg 400w,\n/static/1b289d874439805d34eead0c1756920b/14b42/feature.jpg 800w,\n/static/1b289d874439805d34eead0c1756920b/47498/feature.jpg 1200w,\n/static/1b289d874439805d34eead0c1756920b/0e329/feature.jpg 1600w,\n/static/1b289d874439805d34eead0c1756920b/ee1b0/feature.jpg 1721w","sizes":"(max-width: 800px) 100vw, 800px"}}}}}},"pageContext":{"id":"7493a8a0-9c14-5451-bd26-25fb2a5b89f4"}},"staticQueryHashes":["2933417362","3079204723"]}