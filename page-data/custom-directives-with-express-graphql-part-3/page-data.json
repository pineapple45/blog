{"componentChunkName":"component---src-templates-single-post-js","path":"/custom-directives-with-express-graphql-part-3","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Custom directives with express-graphql [Part-3]\",\n  \"slug\": \"custom-directives-with-express-graphql-part-3\",\n  \"date\": \"29-06-2021\",\n  \"featureImage\": \"feature.jpg\",\n  \"excerpt\": \"Adding custom directives using express-graphql and graphql-directive.\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Till now we have the application structure fully setup. If you are directly coming over here to part 3 , I am assuming you have the base structure of your app completed, which includes setting up the express-graphql server , graphql-schema and corrosponding resolvers. If you haven't I highly recommend checking out part-1 and part-2. Otherwise, let's start!\"), mdx(\"p\", null, \"\\uD83D\\uDCCD Final code: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/main\"\n  }, \"Link\")), mdx(\"p\", null, \"There are only 2 main things left:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Authentication\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Authorisation\")), mdx(\"p\", null, \"We will be using JWT authentication method for loging in the user.\"), mdx(\"h3\", {\n    \"id\": \"choosing-a-wise-logic-for-authentication--authorisation\"\n  }, \"Choosing a wise logic for authentication & authorisation\"), mdx(\"p\", null, \"If you have worked with REST API, imo it is a bit easier to implement both of the functionalities. We can just create a middleware and apply the same middleware to each of the routes(\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"get\"), \" requests) that we either want to authenticate or on top of that authorize. But how will we implement that in graphql ? We have only a single\\nroute \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"http://your-host-url/graphql\"), \". We are left with 2 choices.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Either attach a special property to each incoming request and then check in each of the resolver functions(users, posts, comments, likes etc) weather the resolver should fulfill the request or not!\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Attatch custom resolver directly to each of our query , mutation or type definations in our graphql schema. Each custom resolver will have a seperate implementation logic where it will be checked weather the request should even reach the resolver or not?\")), mdx(\"p\", null, \"Now both the methods can be used. But personally I would prefer to go with second one. I think this is a good approach because this approach has quite a lot of benefits. The most visible ones are:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Code becomes much more modular. Write less code with same functionality!\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Attatching a special property to each incoming request and then check where request should be fullfilled or not inside the resolver is cumbersome. As you can imagine when projects become larger, the resolvers will also increase. Managing logic for authentication/authorisation becomes really tedious and it may happen that\\nyou may forget adding this logic in some resolvers. The first approach is good enough for smaller projects.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Provides a REST like architecture. It kind of takes a middleware approach very similar to REST as you will see in a bit.\")), mdx(\"h3\", {\n    \"id\": \"installing-graphql-directive-package\"\n  }, \"Installing graphql-directive package\"), mdx(\"p\", null, \"If you haven't already, download the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.npmjs.com/package/graphql-directive\"\n  }, \"graphql-directive\"), \" package.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-cmd\"\n  }, \"yarn add graphql-directive\\n// or\\nnpm i graphql-directive\\n\")), mdx(\"p\", null, \"\\uD83D\\uDC49 Please note the version number for 'graphql' package and to specifically use \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"14.6.0\"), \" as I was having a couple of problems with newer version of graphql package.\"), mdx(\"h3\", {\n    \"id\": \"adding-types-for-graphql-directive-package\"\n  }, \"Adding types for graphql-directive package\"), mdx(\"p\", null, \"Since no type are available for graphql-directive package that we installed, we create a graphql-directive.d.ts file in the root with content as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"declare module \\\"graphql-directive\\\"\\n\")), mdx(\"h3\", {\n    \"id\": \"so-how-does-graphql-directive-package-works\"\n  }, \"So, how does graphql-directive package works?\"), mdx(\"p\", null, \"To better understand take a carefull look at the following diagram:\"), mdx(\"p\", null, mdx(\"undefined\", {\n    parentName: \"p\"\n  }, \"\\n      \", mdx(\"div\", {\n    \"className\": \"gria-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"overflow\": \"hidden\"\n    }\n  }, \"\\n      \\n        \\n          \", mdx(\"div\", {\n    parentName: \"div\",\n    \"className\": \"gria-image-padding\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"paddingBottom\": \"104.5%\"\n    }\n  }), \"\\n        \\n        \\n      \\n      \", mdx(\"div\", {\n    parentName: \"div\",\n    \"className\": \"gria-image-placeholder\",\n    \"style\": {\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\",\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"background\": \"#fff url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAC6ElEQVQ4y5WUC28aRxSF/f//SpU2jpKqSiVLaVLbaVrb2MUELGyzBNbAAvue3Xl90cyyFGo7Ua50tSPtnTPn3NeBtRalFMaYPddao7SmNRfXmpQSIQRVVXl357qufcyB+5nnOWVZUhSFD9ba+EcKUflvC+Yuu/NisWAwGDAcDr3f3Nwwm818zIFjoo3BGgOYlo+/qJVqmCrFcrnk6OiIJImZzWd0u116vR79fp/r62smk8kG0DQgeWUZRxV3YcrDWqGMxbjHNl5XNeE0xGiDVtqrccra71ayk+cY1cqyzhVRLEhKjXGAxmzzloiYMA4J5iMe1iHG6G0q2rgNYMPgP8kWbFOYJn9N8L/BFT//8YLDDy856R+jjdqCuLgtoHvEHZ7z1tbFmvE84MtiTJQu9qq/B8gTtgvmclbmgmSdIfIKayxFJojXKbJWXtE+Qx4zZAdQFIK/33X48+0n+p0hWmq6J32ufrtkNmyYtoC+yruyWjMWlLZoC6JSrFcZ8SojSQqf5bpQ1IlAVk1buQq7nG8lW11TTi7Jxx3vWXBOFlyg5z3ssg/rAYgZyegfks8n2GK+kWhI05QwDH37ONAGUAlW3d+ZnL3xPj17Q3j+K3HviPzmHXp0jElGVNMe8raDLSJsg+iB9c6IekAjS6Znrxm8/4nbk1+83388JPj0iruPh8Tdt1AuHhXu2Spbo0iCDsvbM5LROfn4wktu01BNrzBV+uSieBLQyJgyHVPlE2Sdejmt+yJUGcWyRxFdI8v59xmKVZcv3RdMP79ExAO0bqalnRJTRYjgmPLuAzK+3+lV/IjKzUbakVxjVOHdGolSGrvdO+zwfc7sN/rQgrYWuVhQXl5gROnDXSXdrqxr2Ui0lqxU3Icx99MV41lGWbdt878pcYr1Q0j11ykyTVHGIGVNkiREUeQXrVtt0yjnuBNwejni9GrMMq33Z7ll61Z/mSYsg8Bf/BF7BNjOdi0lpWOyU83vucvXV9YkWYt625jSAAAAAElFTkSuQmCC) center / cover no-repeat\"\n    }\n  }), \"\\n    \\n    \", mdx(\"picture\", {\n    parentName: \"div\"\n  }, \"\\n      \", mdx(\"source\", {\n    parentName: \"picture\",\n    \"srcSet\": [\"/static/6d266ce8c382f3c74fa8da71c438c4c6/772e8/nqTdaeXTP.png 200w\", \"/static/6d266ce8c382f3c74fa8da71c438c4c6/e17e5/nqTdaeXTP.png 400w\", \"/static/6d266ce8c382f3c74fa8da71c438c4c6/5a190/nqTdaeXTP.png 800w\", \"/static/6d266ce8c382f3c74fa8da71c438c4c6/c1b63/nqTdaeXTP.png 1200w\", \"/static/6d266ce8c382f3c74fa8da71c438c4c6/10ab7/nqTdaeXTP.png 1552w\"]\n  }), \"\\n      \", mdx(\"img\", {\n    parentName: \"picture\",\n    \"className\": \"gria-image\",\n    \"src\": \"/static/6d266ce8c382f3c74fa8da71c438c4c6/5a190/nqTdaeXTP.png\",\n    \"srcSet\": [\"/static/6d266ce8c382f3c74fa8da71c438c4c6/772e8/nqTdaeXTP.png 200w\", \"/static/6d266ce8c382f3c74fa8da71c438c4c6/e17e5/nqTdaeXTP.png 400w\", \"/static/6d266ce8c382f3c74fa8da71c438c4c6/5a190/nqTdaeXTP.png 800w\", \"/static/6d266ce8c382f3c74fa8da71c438c4c6/c1b63/nqTdaeXTP.png 1200w\", \"/static/6d266ce8c382f3c74fa8da71c438c4c6/10ab7/nqTdaeXTP.png 1552w\"],\n    \"title\": \"custom-directive-workflow.png\",\n    \"alt\": \"custom-directive-workflow.png\",\n    \"loading\": \"lazy\",\n    \"style\": {\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\",\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"objectFit\": \"cover\",\n      \"objectPosition\": \"center center\"\n    }\n  }), \"\\n    \"), \"\\n  \\n      \"), \"\\n    \")), mdx(\"p\", null, \"\\uD83D\\uDC49 I wanted to give you a heads up that we define the graphql context in the root index.ts file of our server where we initialize our graphql-server. We will also update our code to define the context in a little bit. To give you a preview how that will look, it would be like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"app.use(\\\"/graphql\\\", (req, res) => {\\n  return graphqlHTTP({\\n    schema: schema,\\n    rootValue: rootResolver,\\n    graphiql: true,\\n    context: { req, res }, // we pass context here which will be received by aur directive resolvers\\n  })(req, res)\\n})\\n\")), mdx(\"h3\", {\n    \"id\": \"adding-graphql-directive-resolvers\"\n  }, \"Adding graphql-directive resolvers\"), mdx(\"p\", null, \"Folder structure for adding directives will be as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"-src\\n--graphql\\n---directives\\n----hasAuthorisation\\n----isAuthenticated\\n----upperCase\\n----index.ts\\n.\\n.\\n\")), mdx(\"p\", null, \"Now we will implement resolvers for our custom directives\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* hasAuthorisation */\\nimport jwt from \\\"jsonwebtoken\\\"\\n\\nexport const hasAuthorisation = async (\\n  resolve: any,\\n  directiveArgs: any,\\n  obj: any,\\n  context: any,\\n  info: any\\n) => {\\n  const authHeader = context.req.get(\\\"authorization\\\")\\n  console.log(authHeader)\\n  if (authHeader === undefined || context.authHeader === \\\"\\\")\\n    throw new Error(`you are unauthenticated`)\\n\\n  const token = authHeader.split(\\\" \\\")[1]\\n  if (!token || token === \\\"\\\") throw new Error(\\\"Token not found or has expired\\\")\\n\\n  let decodedToken: any\\n  try {\\n    decodedToken = jwt.verify(token, process.env.JWT_SECRET_KEY as string)\\n  } catch (error: any) {\\n    if (!token || token === \\\"\\\") throw new Error(error)\\n  }\\n\\n  if (!decodedToken) throw new Error(\\\"Token verification failed\\\")\\n\\n  // check authorisation roles here\\n  const roleToCheckFrom = obj && obj.roles\\n  if (roleToCheckFrom.indexOf(decodedToken.role) === -1)\\n    throw new Error(\\\"Not Authorised\\\")\\n  return resolve()\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* isAuthenticated */\\nimport jwt from \\\"jsonwebtoken\\\"\\n\\nexport const isAuthenticated = async (\\n  resolve: any,\\n  directiveArgs: any,\\n  obj: any,\\n  context: any,\\n  info: any\\n) => {\\n  // console.log(context.req);\\n  const authHeader = context.req.get(\\\"Authorization\\\")\\n  console.log(authHeader)\\n  if (authHeader === undefined || context.authHeader === \\\"\\\")\\n    throw new Error(`you are unauthenticated`)\\n\\n  const token = authHeader.split(\\\" \\\")[1]\\n  if (!token || token === \\\"\\\") throw new Error(\\\"Token not found or has expired\\\")\\n\\n  let decodedToken: any\\n  try {\\n    decodedToken = jwt.verify(token, process.env.JWT_SECRET_KEY as string)\\n  } catch (error: any) {\\n    if (!token || token === \\\"\\\") throw new Error(error)\\n  }\\n\\n  if (!decodedToken) throw new Error(\\\"Token verification failed\\\")\\n\\n  return resolve()\\n}\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* upperCase */\\nexport const upperCase = async (\\n  resolve: any,\\n  directiveArgs: any,\\n  obj: any,\\n  context: any,\\n  info: any\\n) => {\\n  const value = await resolve()\\n  return String(value).toUpperCase()\\n}\\n\")), mdx(\"p\", null, \"In the above custom directive resolvers, we are creating an asynchronous function that takes 5 arguments:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"resolve\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"directiveArgs\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"obj\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"context\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"info\")), mdx(\"p\", null, \"So what do they all mean? I will copy a part of documentation written in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.npmjs.com/package/graphql-directive\"\n  }, \"graphql-directive npm package\"), \" below that exactly describes what all of these mean. But what I would suggest is logging out each of these in your console to see what output each of them give.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"resolve\"), \": Resolve is a function that returns the result of the directive field. For consistency, it always returns a promise resolved with the original field resolver.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"obj\"), \": The object that contains the result returned from the resolver on the parent field, or, in the case of a top-level Query field, the rootValue passed from the server configuration. This argument enables the nested nature of GraphQL queries.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"directiveArgs\"), \": An object with the arguments passed into the directive in the query or schema. For example, if the directive was called with @dateFormat(format: \\\"DD/MM/YYYY\\\"), the args object would be: { \\\"format\\\": \\\"DD/MM/YYYY\\\" }.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"context\"), \": This is an object shared by all resolvers in a particular query, and is used to contain per-request state, including authentication information, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/graphql/dataloader\"\n  }, \"dataloader \"), \" instances, and anything else that should be taken into account when resolving the query.\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"info\"), \": This argument should only be used in advanced cases, but it contains information about the execution state of the query, including the field name, path to the field from the root, and more. It\\u2019s only documented in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/graphql/graphql-js/blob/c82ff68f52722c20f10da69c9e50a030a1f218ae/src/type/definition.js#L489-L500\"\n  }, \"GraphQL.js source code\"), \" .\"))), mdx(\"p\", null, \"If you are not able to understand all of these arguments , then it's all fine because we will be using only 3 of these which are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"resolve \"), \", \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"obj \"), \"and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"context\")), mdx(\"p\", null, \"In \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"upperCase \"), \"resolver we execute resolve() function and we receive the input value which needs to be converted into upperCase word.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"context \"), \"argument is an object that has all the properties that we passed earlier from our root index.ts file.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"obj \"), \"argument is an object that consists of all properties specified with the directive in our graphql schema. For eg. below in the schema where we declare our directives, with \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"@hasAuthorisation\"), \" directive , we use roles property as '@hasAuthorisation(roles: \", \"[ADMIN]\", \")' where roles is an array and can consist of multiple roles to check from like ADMIN , MODERATOR etc. we can then access roles through \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"obj\"), \" argument like \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"obj.roles\"), \"!\"), mdx(\"p\", null, \"\\uD83D\\uDC49 Note that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"@hasAuthorisation\"), \" directive also covers the logic for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"@isAuthenticated\"), \". So while using the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"@hasAuthorisation\"), \" directive, even if the user is the correctly authorised one, if user is not authenticated or as I should say the request header is empty with no Authorization token , graphql will give error message of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not authenticated!\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* ../graphql/directives/index.ts*/\\nexport * from \\\"./hasAuthorisation\\\"\\nexport * from \\\"./isAuthenticated\\\"\\nexport * from \\\"./upperCase\\\"\\n\")), mdx(\"p\", null, \"\\uD83D\\uDCCC The code till now can be found here: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/all-directive-resolvers-part-3\"\n  }, \"Link\")), mdx(\"h3\", {\n    \"id\": \"updating-graphql-schema-file-to-handle-custom-directives\"\n  }, \"Updating graphql-schema file to handle custom directives\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { buildSchema } from \\\"graphql\\\"\\nimport { addDirectiveResolveFunctionsToSchema } from \\\"graphql-directive\\\"\\nimport { upperCase, isAuthenticated, hasAuthorisation } from \\\"../directives\\\"\\n\\nconst schema = buildSchema(`\\n\\ndirective *@upperCase* on FIELD_DEFINITION | FIELD\\ndirective *@isAuthenticated* on FIELD_DEFINITION | FIELD\\ndirective *@hasAuthorisation(roles: [Role!])* on FIELD_DEFINITION | FIELD\\n\\ninput PostInput {\\n    image: String\\n    title: String!\\n    description: String\\n    creatorId: ID!\\n}\\n\\ntype Post {\\n    _id: ID!\\n    image: String\\n    title: String!\\n    description: String\\n    creator: User!\\n    commentList: [Comment!]\\n    likeList: [Like!]\\n}\\n\\ninput CommentInput {\\n    text: String!\\n    postId: ID!\\n    creatorId: ID!\\n}\\n\\ntype Comment {\\n    _id: ID!\\n    text: String!\\n    post: Post!\\n    creator: User!\\n}\\n\\ninput LikeInput {\\n    postId: ID!\\n    creatorId: ID!\\n}\\n\\ntype Like {\\n    _id: ID!\\n    post: Post!\\n    creator: User!\\n}\\n\\nenum Role {\\n    AUTH_USER\\n    ADMIN\\n    MODERATOR\\n}\\n\\ninput UserInput {\\n    username: String!\\n    email: String!\\n    password: String!\\n}\\n\\ntype User {\\n    _id: ID!\\n    username: String! @upperCase\\n    email: String!\\n    password: String\\n    role: Role!\\n    postList: [Post!]\\n    commentList: [Comment!]\\n    likeList: [Like!]\\n}\\n\\ntype AuthData {\\n    userId: ID!\\n    token: String!\\n    tokenExpiration: Int!\\n}\\n\\ntype RootQuery {\\n  listUsers: [User!] @hasAuthorisation(roles: [ADMIN])\\n  getUserById(_id: ID!): User!\\n  listPosts: [Post!]\\n  getPostById(_id: ID!): Post!\\n  listComments: [Comment!]\\n  getCommentById(_id: ID!): Comment!\\n  listLikes: [Like!]\\n  getLikeById(_id: ID!): Like!\\n  login(usernameOrEmail: String!, password: String!): AuthData!\\n}\\n\\ntype RootMutation {\\n  createUser(user: UserInput): User\\n  deleteUser(_id: ID!): String @hasAuthorisation(roles: [ADMIN])\\n  createPost(post: PostInput): Post @hasAuthorisation(roles: [ADMIN])\\n  deletePost(_id: ID!): String @hasAuthorisation(roles: [ADMIN,MODERATOR])\\n  createComment(comment: CommentInput): Comment\\n  deleteComment(_id: ID!): String @hasAuthorisation(roles: [ADMIN,MODERATOR])\\n  createLike(like: LikeInput): Like\\n  deleteLike(_id: ID!): String\\n  assignRole(role: String! , assignedBy: ID!, assignedUser: ID!): User @hasAuthorisation(roles: [ADMIN])\\n}\\n\\nschema {\\n  query: RootQuery\\n  mutation: RootMutation\\n}\\n`)\\n\\naddDirectiveResolveFunctionsToSchema(schema, {\\n  upperCase,\\n  isAuthenticated,\\n  hasAuthorisation,\\n})\\n\\nexport default schema\\n\")), mdx(\"h3\", {\n    \"id\": \"updating-entry-srcindexts-file-to-pass-graphql-context-to-each-of-the-directive-resolvers\"\n  }, \"Updating entry src/index.ts file to pass graphql context to each of the directive-resolvers\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import * as dotenv from \\\"dotenv\\\"\\ndotenv.config()\\nimport cors from \\\"cors\\\"\\nimport express, { Express, Request, Response, NextFunction } from \\\"express\\\"\\nimport { graphqlHTTP } from \\\"express-graphql\\\"\\nimport schema from \\\"./graphql/schemas\\\"\\nimport rootResolver from \\\"./graphql/resolvers\\\"\\nimport mongoose from \\\"mongoose\\\"\\nconst app: Express = express()\\n\\napp.use(cors())\\n\\napp.use((req: Request, res: Response, next: NextFunction) => {\\n  res.setHeader(\\\"Access-Control-Allow-Origin\\\", \\\"*\\\")\\n  res.setHeader(\\\"Access-Control-Allow-Methods\\\", \\\"POST,GET,OPTIONS\\\")\\n  res.setHeader(\\\"Access-Control-Allow-Headers\\\", \\\"Content-Type, Authorization\\\")\\n  if (req.method === \\\"OPTIONS\\\") {\\n    return res.sendStatus(200)\\n  }\\n  next()\\n})\\n\\napp.use(\\\"/graphql\\\", (req, res) => {\\n  return graphqlHTTP({\\n    schema: schema,\\n    rootValue: rootResolver,\\n    graphiql: true,\\n    context: { req, res }, // we pass context here which will be received by aur directive resolvers\\n  })(req, res)\\n})\\n\\nconst PORT =\\n  process.env.NODE_ENV === \\\"production\\\"\\n    ? process.env.PORT\\n    : process.env.PORT_DEV\\n\\nconst MONGO_URI = process.env.MONGO_URI as string\\n\\nmongoose\\n  .connect(MONGO_URI, { useNewUrlParser: true, useUnifiedTopology: true })\\n  .then(() => {\\n    console.log(\\\"connected to mongodb...\\\")\\n    app.listen(PORT, () => {\\n      console.log(`server started on port ${PORT}`)\\n    })\\n  })\\n  .catch(err => {\\n    console.log(err)\\n  })\\n\")), mdx(\"p\", null, \"\\uD83D\\uDCCC The code till now can be found here: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/full-directives-implementation-part-3\"\n  }, \"Link\")), mdx(\"p\", null, \"Now let's test our custom directives. If you take a look at the updated schema, we have our directives placed at a few different places.\"), mdx(\"p\", null, \"As told above in the note, \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"@hasAuthorisation\"), \" directive also covers the logic for \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"@isAuthenticated\"), \" directive. We will test the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"@hasAuthorisation\"), \" for both authentication and authorization.\"), mdx(\"p\", null, \"\\uD83D\\uDC49 We cannot use graphiql tool for testing these directives since we need to pass headers along with our requests which we want to be either authorized or authenticated. So we will use POSTMAN tool for this purpose.The syntax for setting up queries in POSTMAN is a bit weird, So watch the video below carefully!\"), mdx(\"h4\", {\n    \"id\": \"testing-the-isauthenticated--hasauthorisation-directive\"\n  }, \"Testing the \", mdx(\"em\", {\n    parentName: \"h4\"\n  }, \"@isAuthenticated\"), \" & \", mdx(\"em\", {\n    parentName: \"h4\"\n  }, \"@hasAuthorisation\"), \" directive\"), mdx(\"p\", null, \"First we will send no headers. We will try to list all users. In this case we should get \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"you are unauthenticated\"), \" error message as specified in our\\n\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"@hasAuthorisation\"), \" and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"@isAuthenticated\"), \" custom-directive resolvers.\"), mdx(Video, {\n    videoSrcURL: \"https://www.youtube.com/embed/aE_Kgs4M2VI\",\n    videoTitle: \"https://www.youtube.com/embed/aE_Kgs4M2VI\",\n    mdxType: \"Video\"\n  }), mdx(\"p\", null, \"We get \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"you are unauthenticated\"), \" which means \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"@isAuthenticated\"), \" directive is correctly setup. It also means that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"@hasAuthorisation\"), \" directive is also correctly setup as long as authentication is concerned!\"), mdx(\"h4\", {\n    \"id\": \"testing-hasauthorisation-directive\"\n  }, \"Testing \", mdx(\"em\", {\n    parentName: \"h4\"\n  }, \"@hasAuthorisation\"), \" directive\"), mdx(\"p\", null, \"Now we will take care of authorization part in \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"@hasAuthorisation\"), \". First we will log in. We get the JSON Web Token. Then we use the token and send it along the header and then our custom directive resolver handles authorization. We currently have no user who is an ADMIN or MODERATOR. So as per the schema and custom directives defined in it, if we try to get a list of all users, we should get \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Not Authorised\"), \".\"), mdx(Video, {\n    videoSrcURL: \"https://www.youtube.com/embed/OQn_McPi9II\",\n    videoTitle: \"https://www.youtube.com/embed/OQn_McPi9II\",\n    mdxType: \"Video\"\n  }), mdx(\"h4\", {\n    \"id\": \"testing-the-uppercase-directive\"\n  }, \"Testing the \", mdx(\"em\", {\n    parentName: \"h4\"\n  }, \"@upperCase\"), \" directive\"), mdx(\"p\", null, \"Now to test \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"@upperCase\"), \" directive, we need to get the list of all users since each username has to be shown in uppercase as per our graphql schema. User's list can only be retrieved by an ADMIN. So I will manually update the user role of any one of the user's in our mongodb database to ADMIN. Lets update role of \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"john doe\"), \" to ADMIN:\"), mdx(Video, {\n    videoSrcURL: \"https://www.youtube.com/embed/CmN-K6PW6PQ\",\n    videoTitle: \"https://www.youtube.com/embed/CmN-K6PW6PQ\",\n    mdxType: \"Video\"\n  }), mdx(\"p\", null, \"Now since role of user \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"john doe\"), \" is updated to ADMIN, john should be able to retrieve the list of users successfully. We should also get usernames in uppercase which will confirm that our \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"@upperCase\"), \" directive is working fine:\"), mdx(Video, {\n    videoSrcURL: \"https://www.youtube.com/embed/ThL55acCKNs\",\n    videoTitle: \"https://www.youtube.com/embed/ThL55acCKNs\",\n    mdxType: \"Video\"\n  }), mdx(\"p\", null, \"So finally we get the response that we were looking for and hence this confirms that\\nour custom directives are working as they should....\\uD83C\\uDF89\\uD83C\\uDF89\\uD83C\\uDF89\\uD83C\\uDF89\\uD83C\\uDF89\"), mdx(\"h3\", {\n    \"id\": \"splitting-our-graphql-schemaoptional\"\n  }, \"Splitting our graphql schema(optional)\"), mdx(\"p\", null, \"Now our schema is getting a bit long. As the project grows, it is better to divide the schema\\nbased on different sub-queries,sub-mutations or sub-subscriptions.\\nIf you want to see how this is done a greater detail, watch this awesome video by ben awad: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=4XmQi80nFes\"\n  }, \"Link\")), mdx(\"h3\", {\n    \"id\": \"updated-directory-structure-for-schemas-folder\"\n  }, \"Updated directory structure for schemas folder\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"-src\\n--graphql\\n---schemas\\n----users.ts\\n----posts.ts\\n----comments.ts\\n----likes.ts\\n----index.ts\\n.\\n.\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* ../graphql/schemas/users.ts */\\nexport const types = `\\ntype User {\\n    _id: ID!\\n    username: String! @upperCase\\n    email: String!\\n    password: String\\n    role: Role!\\n    postList: [Post!]\\n    commentList: [Comment!]\\n    likeList: [Like!]\\n} \\n\\ntype AuthData {\\n    userId: ID!\\n    token: String!\\n    tokenExpiration: Int!\\n}\\n\\ninput UserInput {\\n    username: String!\\n    email: String!\\n    password: String!\\n}\\n`\\n\\nexport const queries = `\\nlistUsers: [User!] @hasAuthorisation(roles: [ADMIN])  \\ngetUserById(_id: ID!): User! \\nlogin(usernameOrEmail: String!, password: String!): AuthData!\\n`\\n\\nexport const mutations = `\\ncreateUser(user: UserInput): User\\n  deleteUser(_id: ID!): String @hasAuthorisation(roles: [ADMIN])\\n  assignRole(role: String! , assignedBy: ID!, assignedUser: ID!): User @hasAuthorisation(roles: [ADMIN])\\n\\n`\\n\\nexport const subscriptions = ``\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* ../graphql/schemas/posts.ts */\\nexport const types = `\\ninput PostInput {\\n    image: String\\n    title: String!\\n    description: String\\n    creatorId: ID!\\n}\\n\\ntype Post {\\n    _id: ID!\\n    image: String\\n    title: String!\\n    description: String\\n    creator: User!\\n    commentList: [Comment!]\\n    likeList: [Like!]\\n}\\n`\\n\\nexport const queries = `\\nlistPosts: [Post!]\\ngetPostById(_id: ID!): Post!\\n`\\n\\nexport const mutations = `\\ncreatePost(post: PostInput): Post @hasAuthorisation(roles: [ADMIN])\\n  deletePost(_id: ID!): String @hasAuthorisation(roles: [ADMIN,MODERATOR])\\n`\\n\\nexport const subscriptions = ``\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* ../graphql/schemas/comments.ts */\\nexport const types = `\\ninput CommentInput {\\n    text: String!\\n    postId: ID!\\n    creatorId: ID!\\n}\\n\\ntype Comment {\\n    _id: ID!\\n    text: String!\\n    post: Post!\\n    creator: User!\\n}\\n`\\n\\nexport const queries = `\\nlistComments: [Comment!]\\ngetCommentById(_id: ID!): Comment! \\n`\\n\\nexport const mutations = `\\ncreateComment(comment: CommentInput): Comment\\n  deleteComment(_id: ID!): String @hasAuthorisation(roles: [ADMIN,MODERATOR])\\n`\\n\\nexport const subscriptions = ``\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* ../graphql/schemas/likes.ts */\\nexport const types = `\\ninput LikeInput { \\n    postId: ID!\\n    creatorId: ID!\\n}\\n\\ntype Like {\\n    _id: ID!\\n    post: Post!\\n    creator: User!\\n}\\n`\\n\\nexport const queries = `\\n  listLikes: [Like!]\\n  getLikeById(_id: ID!): Like!\\n`\\n\\nexport const mutations = `\\ncreateLike(like: LikeInput): Like\\n  deleteLike(_id: ID!): String\\n`\\n\\nexport const subscriptions = ``\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"/* ../graphql/schemas/index.ts */\\n//\\nimport { buildSchema } from \\\"graphql\\\"\\nimport { addDirectiveResolveFunctionsToSchema } from \\\"graphql-directive\\\"\\nimport { upperCase, isAuthenticated, hasAuthorisation } from \\\"../directives\\\"\\n\\n// import comparted schemas\\nimport * as postsGQLSchema from \\\"./posts\\\"\\nimport * as commentsGQLSchema from \\\"./comments\\\"\\nimport * as likesGQLSchema from \\\"./likes\\\"\\nimport * as usersGQLSchema from \\\"./users\\\"\\n\\nconst types: string[] = []\\nconst queries: string[] = []\\nconst mutations: string[] = []\\nconst subscriptions = []\\nconst schemas = [\\n  postsGQLSchema,\\n  commentsGQLSchema,\\n  likesGQLSchema,\\n  usersGQLSchema,\\n]\\n\\nschemas.forEach(schema => {\\n  types.push(schema.types)\\n  queries.push(schema.queries)\\n  mutations.push(schema.mutations)\\n  subscriptions.push(schema.subscriptions)\\n})\\n\\nconst schema = buildSchema(`\\n\\ndirective @upperCase on FIELD_DEFINITION | FIELD\\ndirective @isAuthenticated on FIELD_DEFINITION | FIELD\\ndirective @hasAuthorisation(roles: [Role!]) on FIELD_DEFINITION | FIELD\\n\\nenum Role {\\n    AUTH_USER\\n    ADMIN\\n    MODERATOR\\n}\\n\\n${types.join(\\\"\\\\n\\\")}\\n\\n\\ntype RootQuery {\\n    ${queries.join(\\\"\\\\n\\\")}\\n}\\n\\ntype RootMutation {\\n${mutations.join(\\\"\\\\n\\\")}\\n}\\n\\nschema {\\n  query: RootQuery\\n  mutation: RootMutation\\n}\\n`)\\n\\naddDirectiveResolveFunctionsToSchema(schema, {\\n  upperCase,\\n  isAuthenticated,\\n  hasAuthorisation,\\n})\\n\\nexport default schema\\n\")), mdx(\"p\", null, \"I will leave the original schema in a reference.ts file so as to later reference in case needed.\"), mdx(\"p\", null, \"\\uD83D\\uDCCC The code till now can be found here: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/schema-splitting-part-3\"\n  }, \"Link\")), mdx(\"h3\", {\n    \"id\": \"react-app-frontend-setup\"\n  }, \"React App frontend setup\"), mdx(\"p\", null, \"I am using React as my frontend frameworks but you can easily use any other frontend framework such as Angular or svelte. Few other technologies that I am using on my frontend are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.npmjs.com/package/@apollo/client\"\n  }, \"@apollo/client\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.npmjs.com/package/@material-ui/core\"\n  }, \"Material-UI\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.npmjs.com/package/typescript\"\n  }, \"Typescript\"))), mdx(\"p\", null, \"\\uD83D\\uDC49 Note: In the final code repository there is a client-redux folder which also consists of frontend with client graphql implementation using redux. Although , it is important to note that, functionalities such live as refetching of queries , implementaion of custom fetch and error policies is not implemented in this project.\"), mdx(\"p\", null, \"\\uD83D\\uDCCD Final code: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/pineapple45/custom-directives-with-express-graphql/tree/main\"\n  }, \"Link\")), mdx(\"p\", null, \"\\uD83C\\uDF10 Live preview: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://pineapple45.github.io/custom-directives-with-express-graphql/\"\n  }, \"Link\")), mdx(\"h3\", {\n    \"id\": \"final-points\"\n  }, \"Final points\"), mdx(\"p\", null, \"Hope you learnt something useful from this project. In case any queries or doubts, you can comment down below and I will try to resolve them as much as I can. You can also join my \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://discord.gg/cDyttEtkcJ\"\n  }, \"discord channel\"), \" if you want to reach out to me.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"https://media.giphy.com/media/3otPoS81loriI9sO8o/giphy.gif\",\n    \"alt\": \"https://media.giphy.com/media/3otPoS81loriI9sO8o/giphy.gif\"\n  })));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#choosing-a-wise-logic-for-authentication--authorisation","title":"Choosing a wise logic for authentication & authorisation"},{"url":"#installing-graphql-directive-package","title":"Installing graphql-directive package"},{"url":"#adding-types-for-graphql-directive-package","title":"Adding types for graphql-directive package"},{"url":"#so-how-does-graphql-directive-package-works","title":"So, how does graphql-directive package works?"},{"url":"#adding-graphql-directive-resolvers","title":"Adding graphql-directive resolvers"},{"url":"#updating-graphql-schema-file-to-handle-custom-directives","title":"Updating graphql-schema file to handle custom directives"},{"url":"#updating-entry-srcindexts-file-to-pass-graphql-context-to-each-of-the-directive-resolvers","title":"Updating entry src/index.ts file to pass graphql context to each of the directive-resolvers","items":[{"url":"#testing-the-isauthenticated--hasauthorisation-directive","title":"Testing the @isAuthenticated & @hasAuthorisation directive"},{"url":"#testing-hasauthorisation-directive","title":"Testing @hasAuthorisation directive"},{"url":"#testing-the-uppercase-directive","title":"Testing the @upperCase directive"}]},{"url":"#splitting-our-graphql-schemaoptional","title":"Splitting our graphql schema(optional)"},{"url":"#updated-directory-structure-for-schemas-folder","title":"Updated directory structure for schemas folder"},{"url":"#react-app-frontend-setup","title":"React App frontend setup"},{"url":"#final-points","title":"Final points"}]},"headings":[{"depth":3,"value":"Choosing a wise logic for authentication & authorisation"},{"depth":3,"value":"Installing graphql-directive package"},{"depth":3,"value":"Adding types for graphql-directive package"},{"depth":3,"value":"So, how does graphql-directive package works?"},{"depth":3,"value":"Adding graphql-directive resolvers"},{"depth":3,"value":"Updating graphql-schema file to handle custom directives"},{"depth":3,"value":"Updating entry src/index.ts file to pass graphql context to each of the directive-resolvers"},{"depth":4,"value":"Testing the @isAuthenticated & @hasAuthorisation directive"},{"depth":4,"value":"Testing @hasAuthorisation directive"},{"depth":4,"value":"Testing the @upperCase directive"},{"depth":3,"value":"Splitting our graphql schema(optional)"},{"depth":3,"value":"Updated directory structure for schemas folder"},{"depth":3,"value":"React App frontend setup"},{"depth":3,"value":"Final points"}],"frontmatter":{"date":"29-06-2021","excerpt":"Adding custom directives using express-graphql and graphql-directive.","slug":"custom-directives-with-express-graphql-part-3","title":"Custom directives with express-graphql [Part-3]","featureImage":{"publicURL":"/static/1b289d874439805d34eead0c1756920b/feature.jpg","childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAEDBf/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAABy6yMRiD/xAAZEAACAwEAAAAAAAAAAAAAAAAAAgERICH/2gAIAQEAAQUCGSieY//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABgQAAIDAAAAAAAAAAAAAAAAAAABESAi/9oACAEBAAY/AhaTmv8A/8QAGhABAAEFAAAAAAAAAAAAAAAAEQABICFBUf/aAAgBAQABPyEnDBxqUIs//9oADAMBAAIAAwAAABDAD//EABYRAAMAAAAAAAAAAAAAAAAAAAEQYf/aAAgBAwEBPxAxf//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAQEAAQUAAAAAAAAAAAAAAAERACAxQXGR/9oACAEBAAE/ECi0O8MztsvDl2hnJo//2Q==","aspectRatio":1.5384615384615385,"src":"/static/1b289d874439805d34eead0c1756920b/14b42/feature.jpg","srcSet":"/static/1b289d874439805d34eead0c1756920b/f836f/feature.jpg 200w,\n/static/1b289d874439805d34eead0c1756920b/2244e/feature.jpg 400w,\n/static/1b289d874439805d34eead0c1756920b/14b42/feature.jpg 800w,\n/static/1b289d874439805d34eead0c1756920b/47498/feature.jpg 1200w,\n/static/1b289d874439805d34eead0c1756920b/0e329/feature.jpg 1600w,\n/static/1b289d874439805d34eead0c1756920b/ee1b0/feature.jpg 1721w","sizes":"(max-width: 800px) 100vw, 800px"}}}}}},"pageContext":{"id":"488751c7-0e8a-5324-a2b2-4762a7335fcc"}},"staticQueryHashes":["2933417362","3079204723"]}